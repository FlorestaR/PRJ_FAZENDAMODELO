grp = grupos, .combine = 'rbind') %:%
foreach(
niv = parcelas[,grp] %>% unique %>%
as.character %>% sort, .combine = 'rbind'
) %do% {
inGroup = talhoes[,grp] == niv
popSize = round(
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) /
parcelaAreaMedia)
inGroup = parcelas[,grp] == niv
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F]
inventory = calcPars(tempPars, popSize)
inventory$grupo = grp
inventory$nivel = niv
inventory$n     = nrow(tempPars)
inventory$N     = popSize
return(inventory)
}
View(paramEstatisticosACE)
grupos
grp
inGroup
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) /
parcelaAreaMedia)
popSize = round(
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) /
parcelaAreaMedia)
popSize
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) /
parcelaAreaMedia
print(sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) /
parcelaAreaMedia))
print(sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) /
parcelaAreaMedia)
print(sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) /
parcelaAreaMedia)
talhoes[rightAges & !is.na(inGroup) & inGroup,]
talhoes
rightAges
inGroup
inGroup
talhoes[rightAges]$AREA
talhoes[rightAges & !is.na(inGroup)]$AREA
rightAges
is.na(inGroup)
!is.na(inGroup)
talhoes[rightAges]
popSize
paramEstatisticosACE = foreach(
grp = grupos, .combine = 'rbind') %:%
foreach(
niv = parcelas[,grp] %>% unique %>%
as.character %>% sort, .combine = 'rbind'
) %do% {
inGroup = talhoes[,grp] == niv
popSize = round(
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) /
parcelaAreaMedia)
inGroup = parcelas[,grp] == niv
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F]
inventory = calcPars(tempPars, popSize)
inventory$grupo = grp
inventory$nivel = niv
inventory$n     = nrow(tempPars)
inventory$N     = popSize
return(inventory)
}
paramEstatisticosACE
inventory
inGroup
talhoes
talhoes[rightAges & !is.na(inGroup) & inGroup,]
talhoes[rightAges & !is.na(inGroup)]
inGroup
inGroup
grp
talhoes
talhoes[,grp]
niv
inGroup
grp
niv
grp
grupos
foreach(i, vetor[i]){
foreach(i, vetor[i]) %do% {
print(vetor[i])
}
foreach(i, vetor[i]) %do% {
i = i + 1
print(vetor[i])
}
foreach(i = 0, vetor[i]) %do% {
i = i + 1
print(vetor[i])
}
vetor = c(1:20)
foreach(i = 10, vetor[i]) %do% {
i = i + 1
print(vetor[i])
}
vetoraux = 0
foreach(i = vetor) %do% {
i = i + 1
vetoraux = vetor[i]
print(vetoraux[i])
}
foreach(i = vetor) %do% {
i = i + 1
vetoraux = vetor[i]
print(vetoraux[i])
}
result <- foreach(i = 1:5) %do% {
i^2
print(result)
}
result
result <- foreach(i = 1:5) %do% {
i^2
}
result
vetor1 <- foreach(i = 0, vetor[i], .combine = c) %do% {
vetor[i] = vetor [i] + 1
}
vetor1
vetor1 <- foreach(i = 0, .combine = c) %do% {
i = i + 1
#vetor[i] = vetor[i] + 1
}
vetor1
vetor1 <- foreach(i = 1:10, .combine = c) %do% {
i = i + 1
#vetor[i] = vetor[i] + 1
}
vetor1
grupos
grp
niv = parcelas[,grp] %>% unique %>%
as.character %>% sort
niv
parcelas[,grp]
parcelas[,grp] %>% unique
parcelas[,grp] %>% unique %>%
as.character
parcelas[,grp] %>% unique %>%
as.character %>% sort
talhoes[,grp]
niv
inGroup
niv
talhoes[,grp]
inGroup
parcelas[,grp]
niv
inGroup
inGroup = parcelas[,grp] == niv
inGroup
grupos
parcelas[,grp]
parcelas[grp]
class(parcelas[grp])
class(parcelas[,grp])
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame
as.character %>% sort
niv
sort
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort
niv
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort, .combine = 'rbind'
inGroup
niv
talhoes[,grp]
talhoes
niv
talhoes[,grp] == niv
niv
talhoes[,grp] == niv
inGroup
niv
talhoes
talhoes[,grp]
niv
talhoes[,grp] == niv
talhoes[grp] == niv
talhoes
inGroup = talhoes[,grp] == niv
inGroup
talhoes[,grp] == niv
niv
talhoes[,grp] == 3.7
talhoes[,grp] == 5.2
talhoes
talhoes[,grp] == niv
inGroup = parcelas[,grp] == niv
inGroup
parcelas[,grp]
parcelas
niv
inGroup
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F]
tempPars
tempPars = parcelas$IDINV[inGroup, variaveisDeInteresse, drop=F]
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F]$IDINV
tempPars
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F]
tempPars
parcelas
niv
niv
grp
talhoes[,grp]
niv
talhoes["IDINV"] == niv
talhoes[,"IDINV"] == niv
talhoes[,"IDINV"]
inGroup = talhoes[,"IDINV"] == niv
inGroup
niv
grp
grp = grupos, .combine = 'rbind'
grp = grupos
grp
paramEstatisticosACE = foreach(
grp = grupos, .combine = 'rbind') %:%  # Para cada uma das idades (definidas por grupos) os dados serão empilhados em um data.frame (rbind)
foreach(
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort, .combine = 'rbind' # converter para string e organiza em ordem crescente. rbind empilha os resultados
) %do% {
inGroup = talhoes[,grp] == niv
popSize = round(
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) /
parcelaAreaMedia)
inGroup = parcelas[,grp] == niv
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F]
inventory = calcPars(tempPars, popSize)
inventory$grupo = grp
inventory$nivel = niv
inventory$n     = nrow(tempPars)
inventory$N     = popSize
return(inventory)
}
paramEstatisticosACE
talhoes[,grp]
inGroup = talhoes[,grp] == 5.2
inGroup
inGroup = talhoes[,grp] == 3.7
inGroup
niv
inGroup = talhoes[,grp] == niv
inGroup
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort
niv
niv
inGroup = talhoes[,grp] == niv
inGroup
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.numeric
niv
inGroup = talhoes[,grp] == niv
inGroup
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort
niv
inGroup = talhoes[,grp] == niv
inGroup
talhoes[,grp]
talhoes
grupos
grp
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort
niv
niv
talhoes[,grp]
niv
talhoes[,grp] == niv
inGroup = talhoes[,grp] == niv
inGroup
inGroup = parcelas[,grp] == niv
inGroup
talhoes
grupos
grp
niv
parcelas[,grp]
talhoes[,grp]
talhoes[,grp] == niv
niv
grp
niv
grp
talhoes[,grp] == niv
View(talhoes)
talhoes[,grp]
niv
talhoes[,grp]
talhoes[,grp] == niv
talhoes[,grp]
grp
inGroup = talhoes[,grp] == niv #
inGroup
inGroup
talhoes[rightAges & !is.na(inGroup) & inGroup,]
rightAges
talhoes[rightAges]
is.na(inGroup)
inGroup
inGroup
rightAges
talhoes[rightAges & !is.na(inGroup) & inGroup,]
# Cria vetor de (True ou False) para marcar dados que estejam dentro
#      do intervalo de idades de interesse (entre 2 e 6)
rightAges = talhoes$IDINV > 2 & talhoes$IDINV < 6
rightAges
inGroup
talhoes[rightAges & !is.na(inGroup) & inGroup,]
inGroup
parcelaAreaMedia
inGroup
talhoes[,grp]
talhoes
talhoes[rightAges & !is.na(inGroup) & inGroup,]
talhoes[rightAges & !is.na(inGroup) & inGroup,]
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA)
talhoes[rightAges & !is.na(inGroup) & inGroup,]
rightAges
inGroup
inGroup
talhoes[rightAges & !is.na(inGroup) & inGroup,]
talhoes[,grp]
niv
talhoes[,grp]
niv
inGroup
talhoes[inGroup]
talhoes[inGroup]$AREA
talhoes[inGroup,]$AREA
inGroup
talhoes
inGroup = parcelas[,grp] == niv
inGroup
parcelas[,grp]
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F]
tempPars
niv
tempPars
inventory$grupo = grp
inventory$grupo
paramEstatisticosACE$grupo
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo)
if(!require(magrittr))
install.packages("magrittr")
library(magrittr)
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo)
paramEstatisticosACE
paramEstatisticosACE$grupo
base::split(f=paramEstatisticosACE$grupo
base::split(f=paramEstatisticosACE$grupo)
base::split(f=paramEstatisticosACE$grupo)
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo) %>% # %<>% combina o pipe com a atribuição (->). Logo, paramEstatisticosACE irá receber o valor da função seguinte
lapply(function(x) split(x, x$nivel))
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo)
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo) %>% # %<>% combina o pipe com a atribuição (->). Logo, paramEstatisticosACE irá receber o valor da função seguinte
lapply(function(x) split(x, x$nivel))
paramEstatisticosACE = foreach( # Executar linha por linha pode ser didático, mas também pode confundir. O código só realmente funciona com o foreach
grp = grupos, .combine = 'rbind') %:%  # Para cada uma das idades (definidas por grupos) os dados serão empilhados em um data.frame (rbind).
foreach(
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort, .combine = 'rbind' # converter para string e organiza em ordem crescente. rbind empilha os resultados
) %do% {
inGroup = talhoes[,grp] == niv # inGroup recebe TRUE e FALSE. Na primeira volta do foreach o TRUE será 3.7, a segunda volta será o 5.2
popSize = round( # Calcula o tamanho da pop.
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) / # Soma as áreas dos talhões onde as idades estão entre 2 e 6 (rightages), além de que a comparação das idades dos talhões (talhoes[,grp]) com o nível (niv) não tenha resultado em NA e onde inGroup esteja indicado como TRUE (talhoes[inGroup,]$AREA retorna as áreas onde a comparação de talhoes com niv deu como verdadeira)
parcelaAreaMedia)
inGroup = parcelas[,grp] == niv # inGroup classifica como verdadeira ou falsa a comparação da idade da parcela com a idade que niv está recebendo no momento (3.7 ou 5.2)
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F] # Descarta as informações de interesse onde a compração da idade da parcela com a idade de niv são falsas.
inventory = calcPars(tempPars, popSize) # A função calcPars (mesma usada na ACS) recebe MHDOM e VTCC da idade indicada em niv como o df e N é a popSize, calculada acima
inventory$grupo = grp
inventory$nivel = niv
inventory$n     = nrow(tempPars)
inventory$N     = popSize
return(inventory)
}
paramEstatisticosACE
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo)
paramEstatisticosACE
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo) %>% # %<>% combina o pipe com a atribuição (->). Logo, paramEstatisticosACE irá receber o valor da função seguinte
lapply(function(x) split(x, x$nivel))
paramEstatisticosACE = foreach( # Executar linha por linha pode ser didático, mas também pode confundir. O código só realmente funciona com o foreach
grp = grupos, .combine = 'rbind') %:%  # Para cada uma das idades (definidas por grupos) os dados serão empilhados em um data.frame (rbind).
foreach(
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort, .combine = 'rbind' # converter para string e organiza em ordem crescente. rbind empilha os resultados
) %do% {
inGroup = talhoes[,grp] == niv # inGroup recebe TRUE e FALSE. Na primeira volta do foreach o TRUE será 3.7, a segunda volta será o 5.2
popSize = round( # Calcula o tamanho da pop.
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) / # Soma as áreas dos talhões onde as idades estão entre 2 e 6 (rightages), além de que a comparação das idades dos talhões (talhoes[,grp]) com o nível (niv) não tenha resultado em NA e onde inGroup esteja indicado como TRUE (talhoes[inGroup,]$AREA retorna as áreas onde a comparação de talhoes com niv deu como verdadeira)
parcelaAreaMedia)
inGroup = parcelas[,grp] == niv # inGroup classifica como verdadeira ou falsa a comparação da idade da parcela com a idade que niv está recebendo no momento (3.7 ou 5.2)
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F] # Descarta as informações de interesse onde a compração da idade da parcela com a idade de niv são falsas.
inventory = calcPars(tempPars, popSize) # A função calcPars (mesma usada na ACS) recebe MHDOM e VTCC da idade indicada em niv como o df e N é a popSize, calculada acima
inventory$grupo = grp
inventory$nivel = niv
inventory$n     = nrow(tempPars)
inventory$N     = popSize
return(inventory)
}
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo) %>% # %<>% combina o pipe com a atribuição (->). Logo, paramEstatisticosACE irá receber o valor da função seguinte
lapply(function(x) split(x, x$nivel))
globalparamEstatisticosACE = popFromStrata(paramEstatisticosACE)
globalparamEstatisticosACE
paramEstatisticosACE
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo)
paramEstatisticosACE$grupo
paramEstatisticosACE = foreach( # Executar linha por linha pode ser didático, mas também pode confundir. O código só realmente funciona com o foreach
grp = grupos, .combine = 'rbind') %:%  # Para cada uma das idades (definidas por grupos) os dados serão empilhados em um data.frame (rbind).
foreach(
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort, .combine = 'rbind' # converter para string e organiza em ordem crescente. rbind empilha os resultados
) %do% {
inGroup = talhoes[,grp] == niv # inGroup recebe TRUE e FALSE. Na primeira volta do foreach o TRUE será 3.7, a segunda volta será o 5.2
popSize = round( # Calcula o tamanho da pop.
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) / # Soma as áreas dos talhões onde as idades estão entre 2 e 6 (rightages), além de que a comparação das idades dos talhões (talhoes[,grp]) com o nível (niv) não tenha resultado em NA e onde inGroup esteja indicado como TRUE (talhoes[inGroup,]$AREA retorna as áreas onde a comparação de talhoes com niv deu como verdadeira)
parcelaAreaMedia)
inGroup = parcelas[,grp] == niv # inGroup classifica como verdadeira ou falsa a comparação da idade da parcela com a idade que niv está recebendo no momento (3.7 ou 5.2)
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F] # Descarta as informações de interesse onde a compração da idade da parcela com a idade de niv são falsas.
inventory = calcPars(tempPars, popSize) # A função calcPars (mesma usada na ACS) recebe MHDOM e VTCC da idade indicada em niv como o df e N é a popSize, calculada acima
inventory$grupo = grp
inventory$nivel = niv
inventory$n     = nrow(tempPars)
inventory$N     = popSize
return(inventory)
}
paramEstatisticosACE$grupo
paramEstatisticosACE$nivel
paramEstatisticosACE$grupo
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo)
paramEstatisticosACE
paramEstatisticosACE = foreach( # Executar linha por linha pode ser didático, mas também pode confundir. O código só realmente funciona com o foreach
grp = grupos, .combine = 'rbind') %:%  # Para cada uma das idades (definidas por grupos) os dados serão empilhados em um data.frame (rbind).
foreach(
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort, .combine = 'rbind' # converter para string e organiza em ordem crescente. rbind empilha os resultados
) %do% {
inGroup = talhoes[,grp] == niv # inGroup recebe TRUE e FALSE. Na primeira volta do foreach o TRUE será 3.7, a segunda volta será o 5.2
popSize = round( # Calcula o tamanho da pop.
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) / # Soma as áreas dos talhões onde as idades estão entre 2 e 6 (rightages), além de que a comparação das idades dos talhões (talhoes[,grp]) com o nível (niv) não tenha resultado em NA e onde inGroup esteja indicado como TRUE (talhoes[inGroup,]$AREA retorna as áreas onde a comparação de talhoes com niv deu como verdadeira)
parcelaAreaMedia)
inGroup = parcelas[,grp] == niv # inGroup classifica como verdadeira ou falsa a comparação da idade da parcela com a idade que niv está recebendo no momento (3.7 ou 5.2)
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F] # Descarta as informações de interesse onde a compração da idade da parcela com a idade de niv são falsas.
inventory = calcPars(tempPars, popSize) # A função calcPars (mesma usada na ACS) recebe MHDOM e VTCC da idade indicada em niv como o df e N é a popSize, calculada acima
inventory$grupo = grp
inventory$nivel = niv
inventory$n     = nrow(tempPars)
inventory$N     = popSize
return(inventory)
}
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$nivel)
paramEstatisticosACE
paramEstatisticosACE = foreach( # Executar linha por linha pode ser didático, mas também pode confundir. O código só realmente funciona com o foreach
grp = grupos, .combine = 'rbind') %:%  # Para cada uma das idades (definidas por grupos) os dados serão empilhados em um data.frame (rbind).
foreach(
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort, .combine = 'rbind' # converter para string e organiza em ordem crescente. rbind empilha os resultados
) %do% {
inGroup = talhoes[,grp] == niv # inGroup recebe TRUE e FALSE. Na primeira volta do foreach o TRUE será 3.7, a segunda volta será o 5.2
popSize = round( # Calcula o tamanho da pop.
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) / # Soma as áreas dos talhões onde as idades estão entre 2 e 6 (rightages), além de que a comparação das idades dos talhões (talhoes[,grp]) com o nível (niv) não tenha resultado em NA e onde inGroup esteja indicado como TRUE (talhoes[inGroup,]$AREA retorna as áreas onde a comparação de talhoes com niv deu como verdadeira)
parcelaAreaMedia)
inGroup = parcelas[,grp] == niv # inGroup classifica como verdadeira ou falsa a comparação da idade da parcela com a idade que niv está recebendo no momento (3.7 ou 5.2)
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F] # Descarta as informações de interesse onde a compração da idade da parcela com a idade de niv são falsas.
inventory = calcPars(tempPars, popSize) # A função calcPars (mesma usada na ACS) recebe MHDOM e VTCC da idade indicada em niv como o df e N é a popSize, calculada acima
inventory$grupo = grp
inventory$nivel = niv
inventory$n     = nrow(tempPars)
inventory$N     = popSize
return(inventory)
}
grupos
paramEstatisticosACE
# Resultados do inventário (estimação + inferência)
#             pelo método Amostragem Casual Estratificada (ACE)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
paramEstatisticosACE = foreach( # Executar linha por linha pode ser didático, mas também pode confundir. O código só realmente funciona com o foreach
grp = grupos, .combine = 'rbind') %:%  # Para cada uma das idades (definidas por grupos) os dados serão empilhados em um data.frame (rbind).
foreach(
niv = parcelas[,grp] %>% unique %>% # essa , antes do grp é para que a informação fique contida em um vetor numérico. Sem a vírgula, a informação é armazenada em um data.frame. Unique reduz as redundânicas.
as.character %>% sort, .combine = 'rbind' # converter para string e organiza em ordem crescente. rbind empilha os resultados
) %do% {
inGroup = talhoes[,grp] == niv # inGroup recebe TRUE e FALSE. Na primeira volta do foreach o TRUE será 3.7, a segunda volta será o 5.2
popSize = round( # Calcula o tamanho da pop.
sum(talhoes[rightAges & !is.na(inGroup) & inGroup,]$AREA) / # Soma as áreas dos talhões onde as idades estão entre 2 e 6 (rightages), além de que a comparação das idades dos talhões (talhoes[,grp]) com o nível (niv) não tenha resultado em NA e onde inGroup esteja indicado como TRUE (talhoes[inGroup,]$AREA retorna as áreas onde a comparação de talhoes com niv deu como verdadeira)
parcelaAreaMedia)
inGroup = parcelas[,grp] == niv # inGroup classifica como verdadeira ou falsa a comparação da idade da parcela com a idade que niv está recebendo no momento (3.7 ou 5.2)
tempPars = parcelas[inGroup, variaveisDeInteresse, drop=F] # Descarta as informações de interesse onde a compração da idade da parcela com a idade de niv são falsas.
inventory = calcPars(tempPars, popSize) # A função calcPars (mesma usada na ACS) recebe MHDOM e VTCC da idade indicada em niv como o df e N é a popSize, calculada acima
inventory$grupo = grp
inventory$nivel = niv
inventory$n     = nrow(tempPars)
inventory$N     = popSize
return(inventory)
}
paramEstatisticosACE
paramEstatisticosACE %<>% base::split(f=paramEstatisticosACE$grupo) %>% # %<>% combina o pipe com a atribuição (->). Logo, paramEstatisticosACE irá receber o valor da função seguinte. ::base.split garante que a função split da base R seja executada mesmo que haja outro pacote com uma função split sendo executado. O split separa o resultado dos parâmeteros estatísticos com base no grupo, que é grp, logo, "IDINV"
lapply(function(x) split(x, x$nivel))
paramEstatisticosACE
globalparamEstatisticosACE = popFromStrata(paramEstatisticosACE)
globalparamEstatisticosACE
save.image("C:/GitRepo/PRJ_FAZENDAMODELO/BATCHR/ACE-andamento-03-09.RData")
