for (i in 1:nrow(df_shp_talhoes)) {
shp_parcela <- df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela
las_crop <- clip_roi(ctg_tile, shp_parcela)
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Armazene as métricas na lista
metrics_list[[i]] <- metrics
}
aux_df_shp_talhoes
View(aux_df_shp_talhoes)
# Inicialize uma lista para armazenar as métricas de cada parcela
metrics_list <- list()
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(df_shp_talhoes)) {
shp_parcela <- df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela
las_crop <- clip_roi(ctg_tile, shp_parcela)
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Armazene as métricas na lista
metrics_list[[i]] <- metrics
}
df_shp_talhoes
# Inicialize uma lista para armazenar as métricas de cada parcela
metrics_list <- list()
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(df_shp_talhoes)) {
shp_parcela <- df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Armazene as métricas na lista
metrics_list[[i]] <- metrics
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- NA
}
}
metrics_list <- list()
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(aux_df_shp_talhoes)) {
shp_parcela <- aux_df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Armazene as métricas na lista
metrics_list[[i]] <- metrics
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- NA
}
}
metrics_list
View(metrics_list)
# Inicialize uma lista para armazenar as métricas de cada parcela
metricas_teste.data.frame
for (i in 1:nrow(aux_df_shp_talhoes)) {
shp_parcela <- aux_df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Armazene as métricas na lista
metrics_list[[i]] <- metrics
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- NA
}
}
metrics_list
for (i in 1:nrow(aux_df_shp_talhoes)) {
shp_parcela <- aux_df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Armazene as métricas na lista
metrics_list[i] <- metrics
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[i] <- NA
}
}
metrics_list
for (i in 1:nrow(aux_df_shp_talhoes)) {
shp_parcela <- aux_df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- as.data.frame(cloud_metrics(las_crop, func = .stdmetrics_z))
# Armazene as métricas na lista
metrics_list[i] <- metrics
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[i] <- NA
}
}
metrics_list
# Calcule as métricas para essa parcela
metrics <- as.data.frame(cloud_metrics(las_crop, func = .stdmetrics_z))
metrics
for (i in 1:nrow(aux_df_shp_talhoes)) {
shp_parcela <- aux_df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- as.data.frame(cloud_metrics(las_crop, func = .stdmetrics_z))
# Armazene as métricas na lista
as.data.frame(metrics_list[i]) <- metrics
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[i] <- NA
}
}
# Inicialize uma lista para armazenar as métricas de cada parcela
metrics_list <- list()
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(df_shp_talhoes)) {
shp_parcela <- df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Inicialize uma lista para armazenar as métricas de cada parcela
metrics_list <- list()
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(aux_df_shp_talhoes)) {
shp_parcela <- aux_df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
metrics_df_final
View(metrics_df_final)
aux_df_shp_talhoes
View(aux_df_shp_talhoes)
metrics_list <- list()
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(aux_df_shp_talhoes)) {
shp_parcela <- aux_df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list, df_shp_talhoes_aux)
View(aux_df_shp_talhoes)
# Inicialize uma lista para armazenar as métricas de cada parcela
metrics_list <- list()
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(df_shp_talhoes)) {
shp_parcela <- df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
for (i in 1:nrow(aux_df_shp_talhoes)) {
shp_parcela <- aux_df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Adicionar um identificador de parcela em aux_df_shp_talhoes
aux_df_shp_talhoes$parcela_id <- 1:nrow(aux_df_shp_talhoes)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(aux_df_shp_talhoes, metrics_df_final, by = "parcela_id")
# Visualizar o data frame final
head(final_df)
View(final_df)
for (i in 1:nrow(df_shp_talhoes)) {
shp_parcela <- df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Adicionar um identificador de parcela em aux_df_shp_talhoes
aux_df_shp_talhoes$parcela_id <- 1:nrow(df_shp_talhoes)  # Assumindo que cada linha é uma parcela diferente
shp_parcela
nrow(df_shp_talhoes)
shp1_parcela <- shp_parcela[-1593, ]
View(shp_parcela)
shp1_parcela
View(shp1_parcela)
View(df_shp_talhoes)
# Inicialize uma lista para armazenar as métricas de cada parcela
metrics_list <- list()
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(aux_df_shp_talhoes)) {
shp_parcela <- aux_df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Adicionar um identificador de parcela em aux_df_shp_talhoes
aux_df_shp_talhoes$parcela_id <- 1:nrow(aux_df_shp_talhoes)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(aux_df_shp_talhoes, metrics_df_final, by = "parcela_id")
final_df
metrics_list <- list()
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(df_shp_talhoes)) {
shp_parcela <- df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Adicionar um identificador de parcela em aux_df_shp_talhoes
df_shp_talhoes$parcela_id <- 1:nrow(df_shp_talhoes)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(df_shp_talhoes, metrics_df_final, by = "parcela_id")
metrics_list <- list()
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(df_shp_talhoes)) {
shp_parcela <- df_shp_talhoes[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
final_df
View(final_df)
var_boundaryweights <- (fianl_df$AREAPARCEL)/400
var_boundaryweights <- (final_df$AREAPARCEL)/400
final_df$boundaryweights <- var_boundaryweights
X <- tibble(final_df) %>% select(Inventario, boundaryweights, MHDOM, IDINV, zmean,
zq45, zq75, zq95, VTCC, VCCC)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
X$Inventario <- as.integer(X$Inventario)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
View(X)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = X, phase_id = list(phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = X, phase_id = list(phase.col = "Inventario",
terrgrid.id = 2))
class(X)
teste.true.means.Z <- c(1, 24.29965, 4.623077)
teste_reg2p_ex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), exhaustive = teste.true.means.Z)
View(D)
Xteste <- tibble(D1) %>% select(VTCC, Inventario, boundaryweights, MHDOM, IDINV, zmean,
zq45, zq75, zq95, zpcum2, zpcum4, zpcum6,
pzabovezmean, pzabove2)
Xteste <- tibble(D1) %>% select(VTCC, Inventario, MHDOM, IDINV, zmean,
zq45, zq75, zq95, zpcum2, zpcum4, zpcum6,
pzabovezmean, pzabove2)
teste.true.means.Z <- c(1, 24.29965, 4.623077)
teste_reg2p_ex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), exhaustive = teste.true.means.Z)
View(D1)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = list(phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
unique(X$Inventario)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = c(phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
if(!require(forestinventory))             # Package para incluir mapas de fundo
install.packages("forestinventory")
library(forestinventory)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = c(phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = list(phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
str(X)
X$Inventario <- as.numeric(X$Inventario)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = list(phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
X$Inventario <- as.factor(X$Inventario)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = list(phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
X$Inventario <- as.numeric(X$Inventario)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = list(phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
print(head(X$Inventario))
print(phase_id)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = list(phase.col = "Inventario",
terrgrid.id = 2))
save.image("C:/GitRepo/PRJ_FAZENDAMODELO/BATCHR/ACE.RData")
load("C:/GitRepo/PRJ_FAZENDAMODELO/BATCHR/ACE.RData")
X
X$Inventario <- as.numeric(X$Inventario)
X
class(X$Inventario)
str(X)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = list(phase.col = "Inventario",
terrgrid.id = 2))
library(forestinventory)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = list(phase.col = "Inventario",
terrgrid.id = 2))
