data = X,
phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
cluster = "IDINV")
data = X,
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "IDINV")
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "IDINV")
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "IDINV")
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "MHDOM")
op <- onephase(formula = VTCC~1, data = X,
phase_id =list(phase.col = "Inventario",terrgrid.id = 2), cluster = "IDINV")
op <- onephase(formula = VTCC~1, data = X,
phase_id =list(phase.col = "Inventario",terrgrid.id = 2))
View(X)
View(final_df)
X <- tibble(final_df) %>% select(Inventario, boundaryweights, MHDOM, IDINV, zmean,
zq45, zq75, zq95, VTCC, VCCC, ID_Talhao)
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "ID_Talhao")
X <- as.data.frame(X) # Tibble não é uma função nativa do R, é uma função chamada pelo tidyverse. Dessa forma, o formato da tabela que é gerada não é reconhecido pela função twophase() do package forestinventory. O forestinventory reconhece data frames, já que são nativos do R.
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "ID_Talhao")
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2))
unique(X$Inventario)
unique(X$ID_Talhao)
X$Inventario <- as.numeric(X$Inventario) # Converter coluna Inventario para Integer (número) - Deve estar em algum formato numérico para ser reconecida pela função twophase()
X$zq95 <- as.numeric(X$zq95)
X$zq45 <- as.numeric(X$zq45)
X$zq75 <- as.numeric(X$zq75)
X$zmean <- as.numeric(X$zmean)
X$IDINV <- as.numeric(X$IDINV)
unique(X$Inventario)
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "ID_Talhao")
X$ID_Talhao <- as.numeric(X$ID_Talhao)
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "ID_Talhao")
class(zberg$cluster)
X$ID_Talhao <- as.factor(X$ID_Talhao)
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "ID_Talhao")
unique(X$ID_Talhao)
unique(zberg$cluster)
class(zberg$cluster)
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "IDINV")
X$IDINV <- as.numeric(X$IDINV)
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "IDINV")
unique(X$IDINV)
X$IDINV <- as.factor(X$IDINV)
unique(X$IDINV)
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "IDINV")
X$ID_Talhao <- as.factor(X$ID_Talhao)
# Execute novamente a função
op.clust.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
cluster = "ID_Talhao")
op.a <- onephase(formula = tvol~1,
data = grisons,
phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
area = list(sa.col = "smallarea", areas = c("A", "B")))
summary(op.a)
grisons = grisons
View(grisons)
op.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
area = list(sa.col = "IDINV", areas = c("3.7", "5.2")))
summary(op.a)
op.clust.a <- onephase(formula = basal~1,
data = zberg,
phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
cluster = "cluster",
area = list(sa.col = "ismallg23", areas = c("2", "3")))
summary(op.clust.a)
op.clust <- onephase(formula = basal~1, data = zberg,
phase_id = list(phase.col = "phase_id_2p",terrgrid.id = 2),
cluster = "cluster")
summary(op.clust)
View(zberg)
op.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
area = list(sa.col = "IDINV", areas = c("3.7", "5.2")))
summary(op.a)
op.clust <- onephase(formula = VTCC~1, data = X,
phase_id = list(phase.col = "Inventario",terrgrid.id = 2),
cluster = "IDINV")
op.clust <- onephase(formula = VTCC~1, data = X,
phase_id = list(phase.col = "Inventario",terrgrid.id = 2),
cluster = "Inventario")
op.clust <- onephase(formula = VTCC~1, data = X,
phase_id = list(phase.col = "Inventario",terrgrid.id = 2),
cluster = "ID_Talhao")
X$ID_Talhao <- as.factor(X$ID_Talhao)
op.clust <- onephase(formula = basal~1, data = zberg,
phase_id = list(phase.col = "phase_id_2p",terrgrid.id = 2),
cluster = "cluster")
op.clust <- onephase(formula = VTCC~1, data = X,
phase_id = list(phase.col = "Inventario",terrgrid.id = 2),
cluster = "ID_Talhao")
op.clust <- onephase(formula = VTCC~1, data = X,
phase_id = list(phase.col = "Inventario",terrgrid.id = 2),
cluster = "cluster")
op.clust <- onephase(formula = VTCC~1, data = X,
phase_id = list(phase.col = "Inventario",terrgrid.id = 2),
cluster = "ID_Talhao")
class(X$ID_Talhao)
unique(X$ID_Talhao)
anyDuplicated(colnames(X))
class(X$Inventario)
unique(X$Inventario)
class(zberg$phase_id_2p)
class(zberg$cluster)
X$ID_Talhao <- as.factor(X$ID_Talhao)
op.clust <- onephase(formula = VTCC~1, data = X,
phase_id = list(phase.col = "Inventario",terrgrid.id = 2),
cluster = "ID_Talhao")
cçass(X$I])
cçass(X$ID_Talhao)
class(X$ID_Talhao)
op.clust.a <- onephase(formula = VTCC~1, data = X,
phase_id = list(phase.col = "Inventario",terrgrid.id = 2),
cluster = "ID_Talhao")
summary(op.clust.a)
op.clust.a <- onephase(formula = VTCC~1, data = X,
phase_id = list(phase.col = "Inventario",terrgrid.id = 2),
cluster = "ID_Talhao")
?onephase
cçass(X)
class(X)
op.a <- onephase(formula = tvol~1,
data = grisons,
phase_id = list(phase.col = "phase_id_2p", terrgrid.id = 2),
area = list(sa.col = "smallarea", areas = c("A", "B")))
summary(op.a)
op.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
area = list(sa.col = "IDINV", areas = c("3.7", "5.2")))
summary(op.a)
confint(op.a)
op.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
area = list(sa.col = "IDINV", areas = c("3.7", "5.2")))
summary(op.a)
X <- tibble(final_df) %>% select(Inventario, boundaryweights, MHDOM, IDINV, zmean,
zq45, zq75, zq95, VTCC, VCCC)
X$Inventario <- as.numeric(X$Inventario) # Converter coluna Inventario para Integer (número) - Deve estar em algum formato numérico para ser reconecida pela função twophase()
X$zq95 <- as.numeric(X$zq95)
X$zq45 <- as.numeric(X$zq45)
X$zq75 <- as.numeric(X$zq75)
X$zmean <- as.numeric(X$zmean)
X <- as.data.frame(X) # Tibble não é uma função nativa do R, é uma função chamada pelo tidyverse. Dessa forma, o formato da tabela que é gerada não é reconhecido pela função twophase() do package forestinventory. O forestinventory reconhece data frames, já que são nativos do R.
reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV, # formula relaciona os valores de VTCC com zq95 e IDINV
data = X, #  Base de dados utilizada
phase_id = list(phase.col = "Inventario", terrgrid.id = 2)) # phase_id recebe uma lista em que a coluna a ser analisada é a "Inventario" e o identificador da segunda fase é 2
summary(reg2p_nex) # Dá os resultados da Dupla Amostragem
confint(reg2p_nex) # Estatística de confiança
op_ACS <- onephase(formula = VTCC~1, data = X,
phase_id =list(phase.col = "Inventario",terrgrid.id = 2))
summary(op)
summary(reg2p_nex) # Dá os resultados da Dupla Amostragem
confint(op)
confint(reg2p_nex) # Estatística de confiança
op_ACS <- onephase(formula = VTCC~1, data = X,
phase_id =list(phase.col = "Inventario",terrgrid.id = 2))
summary(op_ACS)
confint(op_ACS)
op_ACE <- onephase(formula = VTCC~1, data = X,
phase_id =list(phase.col = "Inventario",terrgrid.id = 2),
area = list(sa.col = "IDINV", areas = c("3.7", "5.2")))
summary(op_ACE)
confint(op_ACE)
length(unique(talhoes$AREA))
talhoes$AREA
talhoes
length(unique(talhoes$IDINV))
for(i in length(unique(talhoes$IDINV)) {
library(foreach)
talhoes
unique(talhoes$IDINV)
unique(talhoes$IDINV)[1]
areasEstratos = unique(talhoes$IDINV)
areasEstratos
idadesEstratos = unique(talhoes$IDINV)
idadesEstratos[1]
idadesEstratos = unique(talhoes$IDINV)
for(i in length(unique(talhoes$IDINV))) {
areasEstratos[i] = sum(talhoes$AREA[idadesEstratos[i]])
}
areasEstratos
idadesEstratos = unique(talhoes$IDINV)
idadesEstratos
idadesEstratos[1]
talhoes$AREA[idadesEstratos[1]
talhoes$AREA[idadesEstratos[1]]
talhoes$AREA[talhoes$IDINV == idadesEstratos[1]]
idadesEstratos = unique(talhoes$IDINV)
for(i in length(unique(talhoes$IDINV))) {
areasEstratos[i] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[1]])
}
areasEstratos
idadesEstratos = unique(talhoes$IDINV)
for(i in length(unique(talhoes$IDINV))) {
areasEstratos[i] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]])
}
areasEstratos
length(unique(talhoes$IDINV))
talhoes$IDINV == idadesEstratos[2]
idadesEstratos[2]
talhoes$AREA[talhoes$IDINV == idadesEstratos[2]]
talhoes$AREA
areasEstratos[2] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[2]])
areasEstratos
rm(areasEstratos)
areasEstratos[2] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[2]])
idadesEstratos = unique(talhoes$IDINV)
for(i in length(unique(talhoes$IDINV))) {
areasEstratos[i] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]])
}
areasEstratos
idadesEstratos = unique(talhoes$IDINV)
for(i in length(unique(talhoes$IDINV))) {
areasEstratos[i] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]])
}
areasEstratos = c()
for(i in length(unique(talhoes$IDINV))) {
areasEstratos[i] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]])
}
areasEstratos
foreach(i in length(unique(talhoes$IDINV))) %do% {
foreach(i = length(unique(talhoes$IDINV))) %do% {
areasEstratos[i] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]])
}
areasEstratos
areasEstratos = c()
foreach(i = length(unique(talhoes$IDINV)), .combine = 'c') %do% {
areasEstratos[i] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]])
}
areasEstratos
areasEstratos[1] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[1]])
areasEstratos
areasEstratos = c()
foreach(i = length(unique(talhoes$IDINV)), .combine = 'c') %do% {
areasEstratos = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[1]])
}
areasEstratos
areasEstratos = c()
foreach(i = length(unique(talhoes$IDINV)), .combine = 'c') %do% {
areasEstratos = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]])
}
areasEstratos
areasEstratos = c()
foreach(i:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
areasEstratos = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]])
}
areasEstratos
areasEstratos = c()
foreach(i:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
areasEstratos[i] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]])
}
areasEstratos
areasEstratos = c()
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
areasEstratos[i] = sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]])
}
areasEstratos
areasEstratos
op_ACE$estimation
areasEstratos
VTCCponderada = c()
rm(VTCCponderada)
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
VTCCponderada[i] = (sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))
}
VTCCponderada = c()
areaTotal = sum(talhoes$AREA)
op_ACE$estimation
op_ACE$estimation$area
op_ACE$estimation$estimate == idadesEstratos[1]
op_ACE$estimation$estimate == idadesEstratos[2]
op_ACE$estimation$area == idadesEstratos[1]
op_ACE$estimation$estimate[op_ACE$estimation$area == idadesEstratos[1]]
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
VTCCponderada[i] = ((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/areaTotal)*(op_ACE$estimation$estimate[op_ACE$estimation$area == idadesEstratos[i]])
}
areasEstratos
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
VTCCponderada[i] = ((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/areaTotal)*(op_ACE$estimation$estimate[op_ACE$estimation$area == idadesEstratos[i]])
}
VTCCponderada = c()
areaTotal = sum(talhoes$AREA)
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
VTCCponderada = ((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/areaTotal)*(op_ACE$estimation$estimate[op_ACE$estimation$area == idadesEstratos[i]])
}
talhoes$AREA
op_ACE$estimation
VTCCponderada_final = sum(VTCCponderada)
VTCCponderada_final
VTCCponderada = c()
areaTotal = sum(talhoes$AREA)
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
VTCCponderada = ((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/areaTotal)*(op_ACE$estimation$estimate[op_ACE$estimation$area == idadesEstratos[i]])
}
VTCCponderada
VTCCponderada = c()
areaTotal = sum(talhoes$AREA)
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
VTCCponderada[i] = ((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/areaTotal)*(op_ACE$estimation$estimate[op_ACE$estimation$area == idadesEstratos[i]])
}
VTCCponderada
VTCCponderada_final = sum(VTCCponderada)
VTCCponderada_final
VTCCponderadaACE = c()
VTCCponderadaACE = c()
areaTotal = sum(talhoes$AREA)
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
VTCCponderadaACE[i] = ((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/areaTotal)*(op_ACE$estimation$estimate[op_ACE$estimation$area == idadesEstratos[i]])
}
VTCCponderada_final = sum(VTCCponderadaACE)
VTCCponderada_final
VTCCponderadaACE_final = sum(VTCCponderadaACE)
VTCCponderadaACE_final
summary(op_ACS)
VTCCponderadaACE_final
paramEstatisticosACS %>%
kbl(caption = "Amostragem Casual Simples (ACS)", align = "r") %>%
kable_classic(full_width = F) %>%
footnote(general = NotaDeRodape,
general_title = "Intensidade amostral",
footnote_as_chunk = T)
summary(op_ACS)
VTCCponderadaACE_final = sum(VTCCponderadaACE)
VTCCponderadaACE_final
load("C:/GitRepo/PRJ_FAZENDAMODELO/BATCHR/DA-forestinventory-finalizada.RData")
#        C:/LiDAR/PRJ_Modelo/NUVENS/     como pasta para os dados LidAR
#        C:/GitRepo/PRJ_Modelo/     sendo GitRepo a pasta onde ficam os
#                                      projetos sincronizados no github
#
# Linguagem de programação:
#       R (v 4.3)
#       RStudio (v. 2023.09.1 Build 494)
#       Pacote lidR* (v 4.0.3 March 11th, 2023) Jean Romain Roussel
#
# Bibliografia complementar:
#  https://github.com/r-lidar/lidR/wiki/Area-based-approach-from-A-to-Z
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1. Carrega pacotes, organiza pastas e define funções locais
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----
if(!require(tidyverse))    # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
if(!require(sf))            # Para manipulação de shapes e outros tipos
install.packages("sf")                      # de dados espacializados
library(sf)
if(!require(tidyterra))           # Package para processar mapas raster
install.packages("tidyterra")
library(tidyterra)
if(!require(terra))           # Package para processar mapas raster
install.packages("terra")
library(terra)
if(!require(stars))                  # Package que permite rasterização
install.packages("stars")
library(stars)
if(!require(tools))           # Package para manipular nomes de aquivos
install.packages("tools")
library(tools)
if(!require(RColorBrewer))          # Package com mais paletas de cores
install.packages("RColorBrewer")
library(RColorBrewer)
if(!require(progress))          # Package com mais paletas de cores
install.packages("progress")
library(progress)
if(!require(reshape2))              # Usado na função que gera gráficos
install.packages("reshape2")         # mais caprichados de correlação
library(reshape2)
if(!require(mapview))             # Package para incluir mapas de fundo
install.packages("mapview")
library(mapview)
if(!require(forestinventory))             # Package para incluir mapas de fundo
install.packages("forestinventory")
library(forestinventory)
# devtools::install_github("Jean-Romain/rlas", dependencies=TRUE)
# devtools::install_github("Jean-Romain/lidR")
if(!require(lidR))                     # PARA MANPULAÇÃO DE DADOS LiDAR
install.packages("lidR") # Se preferir instalar a versão mais recente
library(lidR)              # e tiver o package devtools instalado, rode
# alternativamente as duas linhas acima
if(!require(RCSF))    #        Pacote complementar do lidR e necessário
install.packages("RCSF")           # rodar a função classify_ground()
library(RCSF)
if(!require(future))         # Package que permite ao lidR rodar usando
install.packages("future")          # processamento paralelo de dados
library(future)
op_ACE$estimation$variance
VarponderadaACE = c()
VarponderadaACE = c()
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
VarponderadaACE[i] = (((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/areaTotal)^2)*(op_ACE$estimation$estimate[op_ACE$estimation$area == idadesEstratos[i]])
}
library(foreach)
VarponderadaACE = c()
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
VarponderadaACE[i] = (((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/areaTotal)^2)*(op_ACE$estimation$estimate[op_ACE$estimation$area == idadesEstratos[i]])
}
VarponderadaACE = c()
foreach(i = 0:length(unique(talhoes$IDINV)), .combine = 'c') %do% {
VarponderadaACE[i] = (((sum(talhoes$AREA[talhoes$IDINV == idadesEstratos[i]]))/areaTotal)^2)*(op_ACE$estimation$variance[op_ACE$estimation$area == idadesEstratos[i]])
}
VarponderadaACE_final = sum(VarponderadaACE)
VarponderadaACE_final
erroPadrao_ponderado = sqrt(VarponderadaACE_final)
erroPadrao_ponderado
numeroAmostras = sum(op_ACE$n2)
numeroAmostras
op_ACE$n2
numeroAmostras = sum(op_ACE$estimation$n2)
numeroAmostras
calcCI = function(err, n, alpha=.05){ # err = desvio padrão, n = tamanho da amostra e alpha = nível de significância (95% de confiança)
return(
qt(1 - alpha/2, n-1) * err # Calcula o quantil da distribuição de t de Student para o nível de liberdade desejado. Multiplica pelo erro para obter o intervalo de confiança
) # retorno do ic
}
erroPadrao_ponderado = sqrt(VarponderadaACE_final)
numeroAmostras = sum(op_ACE$estimation$n2)
intervalosConfianca = calcCI(erroPadrao_ponderado, numeroAmostras)
intervalosConfianca
intervaloConfiancaACE = calcCI(erroPadrao_ponderado, numeroAmostras)
op.a <- onephase(formula = VTCC~1,
data = X,
phase_id = list(phase.col = "Inventario", terrgrid.id = 2),
area = list(sa.col = "IDINV", areas = c("3.7", "5.2")))
summary(op.a)
m <- lm(VTCC ~ zq95 + IDINV, data = X)    # Análise de Regressão Linear
summary(m)                          # Mostra os resultados da regressão
VTCCparcelas <- X$VTCC[!is.na(X$VTCC)] # VTCCparcelas recebe os valores não nulos de VTCC contidos em X, ou seja, recebe os valores de VTCC das parcelas de campo
plot(VTCCparcelas, predict(m))              # Gráfico de observado vs predito
abline(0,1)
summary(reg2p_nex) # Dá os resultados da Dupla Amostragem
# Resultados finais da ACE:
intervaloConfiancaACE
VarponderadaACE_final
VTCCponderada_final
erroPadrao_ponderadoACE
erroPadrao_ponderadoACE = sqrt(VarponderadaACE_final)
numeroAmostras = sum(op_ACE$estimation$n2)
intervaloConfiancaACE = calcCI(erroPadrao_ponderadoACE, numeroAmostras)
# Resultados finais da ACE:
VTCCponderada_final
VarponderadaACE_final
erroPadrao_ponderadoACE
intervaloConfiancaACE
?twophase
summary(reg2p_nex_est)
reg2p_nex_est = twophase(
formula = VTCC ~ zq95 + IDINV,
data = X,
phase_id =list(phase.col = "Inventario", terrgrid.id = 2),
small_area = list(sa.col = "IDINV", areas = c("3.7", "5.2"), unbiased = TRUE))
reg2p_nex_est = twophase(
formula = VTCC ~ zq95 + IDINV,
data = X,
phase_id =list(phase.col = "Inventario", terrgrid.id = 2),
cluster NA,
reg2p_nex_est = twophase(
formula = VTCC ~ zq95 + IDINV,
data = X,
phase_id =list(phase.col = "Inventario", terrgrid.id = 2),
cluster = NA,
small_area = list(sa.col = "IDINV", areas = c("3.7", "5.2"), unbiased = TRUE))
# ta errada, tem q arrumar
reg2p_nex_est = twophase(
formula = VTCC ~ zq95 + IDINV,
data = X,
phase_id =list(phase.col = "Inventario", terrgrid.id = 2),
small_area = list(sa.col = "IDINV", areas = c("3.7", "5.2"), unbiased = FALSE))
summary(reg2p_nex_est)
