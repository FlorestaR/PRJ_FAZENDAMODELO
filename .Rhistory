descarteLinha <- nrow(excel) - 1
# Fornos
vetorNumForno <- c(7, 15, 16, 18, 20, 43, 59, 64, 65, 69, 73, 75, 77, 79, 83, 87, 89)
#vetor auxiliar para gerar gráfico
vetoraux <- 1:descarteLinha
#A última linha guarda informações de média para cada parte do forno e não será utilizada
mediaFornos <- excel$Media_fornos[-descarteLinha] #guarda médias
cor <- excel$Corregistro[-nrow(excel)] #guarda situação do corregistro
#Cria df com a média, identificação e situação do corregistro de cada forno
dfMedia <- data.frame(Numeracao_forno = vetorNumForno, Media = mediaFornos, Corregistro = cor)
#gera gráfico de barras simples
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
excel
s <- ggplot(excel, aes(Soma_fornos, fill = Cunhamento))
s + geom_bar(position = "stack")
excel
## Gráfico de barras empilhadas
dadosSemGeral <- excel[-nrow(excel)]
dadosSemGeral
## Gráfico de barras empilhadas
dadosSemGeral <- excel[-vetoraux]
dadosSemGeral
vetoraux
## Gráfico de barras empilhadas
dadosSemGeral <- excel[-descarteLinha]
dadosSemGeral
descarteLinha
## Gráfico de barras empilhadas
dadosSemGeral <- excel[-descarteLinha,]
dadosSemGeral
## Gráfico de barras empilhadas
dadosSemGeral <- excel[-nrow(excel),]
dadosSemGeral
s <- ggplot(excel, aes(Soma_fornos, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Soma_fornos, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(x = vetoraux, y = Soma_fornos, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Soma_fornos, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Forno, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Forno, fill = Cunhamento, Piso))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Forno, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Forno, fill = Corregistro))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Forno, fill = Soma_notas))
s + geom_bar(position = "stack")
dadosSemGeral
s <- ggplot(dadosSemGeral, aes(Forno, fill = Soma_fornos))
s + geom_bar(position = "stack")
s <- ggplot(mpg, aes(cty, fill = drv))
s + geom_bar(position = "fill")
mpg
bd <- read.csv("teste.csv")
bd <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/teste.csv')
bd <- as.data.frame(bd)
bd
bd <- bd[-7,]
bd
bdsoma <- as.data.frame(bd)
bdsoma <- bdsoma[8,]
bdsoma
bdsoma <- as.data.frame(bd)
bdsoma <- bdsoma[7,]
bdsoma
bd <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/teste.csv')
bdsoma <- as.data.frame(bd)
bdsoma <- bdsoma[7,]
bd <- bd[-7,]
bdsoma
bd
bdsoma
bd <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/teste.csv')
s <- ggplot(bd, aes(Notas, fill = Parte))
s + geom_bar(position = "fill")
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
require(ggthemes)
require("ggthemes")
install.packages(ggthemes)
require(scales)
pl <- ggplot(data = mpg, aes(x = manufacter))
pl
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = mpg, aes(x = manufacturer))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = mpg, aes(x = manufacturer, fill = class))
pl <- pl + geom_bar(stat = "count")
pl
mpg
pl <- ggplot(data = mpg, aes(x = manufacturer))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = mpg, aes(x = manufacturer, fill = class))
pl <- pl + geom_bar(stat = "count")
pl
dfMedia
## Gráfico de barras empilhadas
excelSemMDGeral
excel
## Gráfico de barras empilhadas
excelSemMDGeral <- excel[-18,]
excelSemMDGeral
bd
pl <- ggplot(data = bd, aes(x = Notas, fill = Parte))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = bd, aes(y = Notas, fill = Parte))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = bd, aes(x = Notas, fill = Parte))
pl <- pl + geom_bar(stat = "count")
pl
#Lê arquivo e cria df
excel <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/notas-yes-no.csv')
excel <- as.data.frame(excel)
#**######################### Gráfico ######################
#Retirada de linha
descarteLinha <- nrow(excel) - 1
# Fornos
vetorNumForno <- c(7, 15, 16, 18, 20, 43, 59, 64, 65, 69, 73, 75, 77, 79, 83, 87, 89)
#vetor auxiliar para gerar gráfico
vetoraux <- 1:descarteLinha
mediaFornos <- excel$Media_fornos[-descarteLinha] #guarda médias
cor <- excel$Corregistro[-nrow(excel)] #guarda situação do corregistro
#Cria df com a média, identificação e situação do corregistro de cada forno
dfMedia <- data.frame(Numeracao_forno = vetorNumForno, Media = mediaFornos, Corregistro = cor)
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
#Lê arquivo e cria df
excel <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/notas-yes-no.csv')
#Lê arquivo e cria df
excel <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/notas-yes-no.csv')
excel <- as.data.frame(excel)
descarteLinha <- nrow(excel) - 1
# Fornos
vetorNumForno <- c(7, 15, 16, 18, 20, 43, 59, 64, 65, 69, 73, 75, 77, 79, 83, 87, 89)
#vetor auxiliar para gerar gráfico
vetoraux <- 1:descarteLinha
#A última linha guarda informações de média para cada parte do forno e não será utilizada
mediaFornos <- excel$Media_fornos[-descarteLinha] #guarda médias
cor <- excel$Corregistro[-nrow(excel)] #guarda situação do corregistro
#Cria df com a média, identificação e situação do corregistro de cada forno
dfMedia <- data.frame(Numeracao_forno = vetorNumForno, Media = mediaFornos, Corregistro = cor)
#gera gráfico de barras simples
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
p <- ggplot(mpg, aes(displ, hwy)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(class))
## Gráfico de barras empilhadas
excelSemMDGeral
mpg
excelSemMDGeral
## Gráfico de barras empilhadas
excelteste <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/testegrfp.csv')
excelteste
View(excelteste)
View(excelteste)
## Gráfico de barras empilhadas
excelteste <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/testegrfp.csv')
excelteste
p <- ggplot(excelteste, aes(id, notas)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
excelteste
p <- ggplot(excelteste, aes(id, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Forno))
p <- ggplot(excelteste, aes(, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
excelteste
p <- ggplot(excelteste, aes(Forno, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(Forno, Nota)) + geom_bar(stat = "identity")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") #+ gemo_text(aes())
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
excelteste
## Gráfico de barras empilhadas
excelteste <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/testegrfp.csv')
excelteste
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") #+ gemo_text(aes())
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") + gemo_text(aes(x = id, label = Forno))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno))
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno)) + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno)) + xlab("")
## Gráfico de barras empilhadas
excelempilhadas <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/grfbarrasempilhadas.csv')
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno)) + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_point() + geom_text(aes(x = id, label = Forno)) + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno), colour = "white") + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno), colour = "red") + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno), colour = "green") + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
library(ggplot2)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(sf)
library(leaflet)
library(kableExtra)
library(lidR)
library(DescTools)
library(gtsummary)
knitr::opts_chunk$set(echo = TRUE)
prjNam <- "PRJ_GERDAU"
wrkDir <- str_c('C:/GitRepo/', prjNam)
datDir <- str_c('C:/3D/TLS/', prjNam)
\newpage
\newpage
library(ggplot2)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(sf)
library(leaflet)
library(kableExtra)
library(lidR)
library(DescTools)
library(gtsummary)
knitr::opts_chunk$set(echo = TRUE)
prjNam <- "PRJ_GERDAU"
wrkDir <- str_c('C:/GitRepo/', prjNam)
datDir <- str_c('C:/3D/TLS/', prjNam)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(sf)
library(leaflet)
library(kableExtra)
library(lidR)
library(DescTools)
library(gtsummary)
knitr::opts_chunk$set(echo = TRUE)
prjNam <- "PRJ_GERDAU"
wrkDir <- str_c('C:/GitRepo/', prjNam)
datDir <- str_c('C:/3D/TLS/', prjNam)
prjNam    <- "PRJ_FAZENDAMODELO"                             # Nome do projeto
dirRaizNuvens <- str_c('C:/LiDAR/',prjNam, '/NUVENS') # Raiz das nuvens
if(!require(tidyverse))    # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
if(!require(sf))            # Para manipulação de shapes e outros tipos
install.packages("sf")                      # de dados espacializados
library(sf)
if(!require(tidyterra))           # Package para processar mapas raster
install.packages("tidyterra")
library(tidyterra)
if(!require(terra))           # Package para processar mapas raster
install.packages("terra")
library(terra)
if(!require(stars))                  # Package que permite rasterização
install.packages("stars")
library(stars)
if(!require(tools))           # Package para manipular nomes de aquivos
install.packages("tools")
library(tools)
if(!require(RColorBrewer))          # Package com mais paletas de cores
install.packages("RColorBrewer")
library(RColorBrewer)
if(!require(progress))          # Package com mais paletas de cores
install.packages("progress")
library(progress)
if(!require(reshape2))              # Usado na função que gera gráficos
install.packages("reshape2")         # mais caprichados de correlação
library(reshape2)
if(!require(mapview))             # Package para incluir mapas de fundo
install.packages("mapview")
library(mapview)
# devtools::install_github("Jean-Romain/rlas", dependencies=TRUE)
# devtools::install_github("Jean-Romain/lidR")
if(!require(lidR))                     # PARA MANPULAÇÃO DE DADOS LiDAR
install.packages("lidR") # Se preferir instalar a versão mais recente
library(lidR)              # e tiver o package devtools instalado, rode
# alternativamente as duas linhas acima
if(!require(RCSF))    #        Pacote complementar do lidR e necessário
install.packages("RCSF")           # rodar a função classify_ground()
library(RCSF)
if(!require(future))         # Package que permite ao lidR rodar usando
install.packages("future")          # processamento paralelo de dados
library(future)
varteste = 0
load("~/.RData")
if(!require(tidyverse))    # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
if(!require(sf))            # Para manipulação de shapes e outros tipos
install.packages("sf")                      # de dados espacializados
library(sf)
if(!require(tidyterra))           # Package para processar mapas raster
install.packages("tidyterra")
library(tidyterra)
if(!require(terra))           # Package para processar mapas raster
install.packages("terra")
library(terra)
if(!require(stars))                  # Package que permite rasterização
install.packages("stars")
library(stars)
if(!require(tools))           # Package para manipular nomes de aquivos
install.packages("tools")
library(tools)
if(!require(RColorBrewer))          # Package com mais paletas de cores
install.packages("RColorBrewer")
library(RColorBrewer)
if(!require(progress))          # Package com mais paletas de cores
install.packages("progress")
library(progress)
if(!require(reshape2))              # Usado na função que gera gráficos
install.packages("reshape2")         # mais caprichados de correlação
library(reshape2)
if(!require(mapview))             # Package para incluir mapas de fundo
install.packages("mapview")
library(mapview)
if(!require(forestinventory))             # Package para incluir mapas de fundo
install.packages("forestinventory")
library(forestinventory)
# devtools::install_github("Jean-Romain/rlas", dependencies=TRUE)
# devtools::install_github("Jean-Romain/lidR")
if(!require(lidR))                     # PARA MANPULAÇÃO DE DADOS LiDAR
install.packages("lidR") # Se preferir instalar a versão mais recente
library(lidR)              # e tiver o package devtools instalado, rode
# alternativamente as duas linhas acima
if(!require(RCSF))    #        Pacote complementar do lidR e necessário
install.packages("RCSF")           # rodar a função classify_ground()
library(RCSF)
if(!require(future))         # Package que permite ao lidR rodar usando
install.packages("future")          # processamento paralelo de dados
library(future)
prjNam <- "PRJ_FAZENDAMODELO"                               # Nomeia o projeto
varteste = 0
dirProjet <- str_c('C:/GitRepo/',prjNam) # Define diretório de trabalho
if (!dir.exists(dirProjet)) {          # Cria diretório caso não exista
dir.create('C:/GitRepo/', showWarnings = F)
dir.create(dirProjet, showWarnings = F)
}
setwd(dirProjet)                     # Define pasta default de trabalho
datDir <- str_c('C:/LiDAR/', prjNam)    # Define raiz da pasta de dados
if (!dir.exists(datDir)) {           # Cria diretórios caso não existam
dir.create('C:/LiDAR/', showWarnings = F)
dir.create(datDir, showWarnings = F)
}
lidDir <- str_c(datDir, '/NUVENS/')     # Cria sub-pasta p/ dados LiDAR
if (!dir.exists(lidDir)) {
dir.create(lidDir, showWarnings = F)
}
# Leitura do Grid
shp_arquivo  <- "C:/GitRepo/PRJ_FAZENDAMODELO/SHAPES/Grid_finalizado.shp"
shp_talhoes <- st_read(shp_arquivo)
dirNrm <- str_c(dirTal, '/SiNORM')       # Pasta p/ nuvens normalizadas
dirTal <- str_c(dirLAZ, '/TALHOES')        # Pasta p/ nuvens por talhao
dirLAZ  <- str_c(lidDir, anoData[1])   #  Define local das nuvens LiDAR
anoData = "A13"
dirLAZ  <- str_c(lidDir, anoData[1])   #  Define local das nuvens LiDAR
ctg_orig <- readLAScatalog(dirLAZ) # LEITURA DAS NUVENS DE PONTOS LiDAR
opt_select(ctg_orig) <- "xyzic"
dirTal <- str_c(dirLAZ, '/TALHOES')        # Pasta p/ nuvens por talhao
if (!dir.exists(dirTal)) {
dir.create(dirTal, showWarnings = F)
}
dirNrm <- str_c(dirTal, '/SiNORM')       # Pasta p/ nuvens normalizadas
if (!dir.exists(dirNrm)) {
dir.create(dirNrm, showWarnings = F)
}
dirTNrm <- str_c(dirNrm, '/TILES')        # Pasta p/ tiles normalizados
if (!dir.exists(dirTNrm)) {
dir.create(dirTNrm, showWarnings = F)
}
dirTNrm <- str_c(dirNrm, '/TILES')        # Pasta p/ tiles normalizados
if (!dir.exists(dirTNrm)) {
dir.create(dirTNrm, showWarnings = F)
}
# crashou
ctg_gSiN <- readLAScatalog(dirNrm)
# ctg_gSiN <- readLAScatalog(dirTNrm)
opt_output_files(ctg_gSiN) <-     # Onde guardar as nuvens normalizadas
str_c(dirTNrm, "/FzMod_{XLEFT}_{YBOTTOM}")    # renomeadas com coords
opt_chunk_buffer(ctg_gSiN) <- 0     # sem buffers ao redor de cada tile
opt_chunk_size(ctg_gSiN) <- 100                     # em tiles de 100 m
opt_laz_compression(ctg_gSiN) <- TRUE              # Mantém formato LAZ
ctg_tile <- catalog_retile(ctg_gSiN)                        # e executa
ctg_gSiN <- readLAScatalog(dirNrm)
# ctg_gSiN <- readLAScatalog(dirTNrm)
opt_output_files(ctg_gSiN) <-     # Onde guardar as nuvens normalizadas
str_c(dirTNrm, "/FzMod_{XLEFT}_{YBOTTOM}")    # renomeadas com coords
opt_chunk_buffer(ctg_gSiN) <- 0     # sem buffers ao redor de cada tile
opt_chunk_size(ctg_gSiN) <- 250                     # em tiles de 250 m
opt_laz_compression(ctg_gSiN) <- TRUE              # Mantém formato LAZ
ctg_tile <- catalog_retile(ctg_gSiN)                        # e executa
rm(ctg_gNoN, ctg_gSiN, ctg_orig, ctg_talh)
dirParc <- str_c(dirNrm, '/PARCELAS')      # Pasta p/ parcelas clipadas
if (!dir.exists(dirParc)) {
dir.create(dirParc, showWarnings = F)
}
opt_output_files(ctg_tile) <-     # Onde guardar as nuvens das parcelas
str_c(dirParc, "/P_{NUMPARCELA}") # renomeadas pelo respectivo número
opt_select(ctg_tile) <- "xyz"   # Carrega na memória apenas coordenadas
opt_filter(ctg_tile) <- "-drop_z_below 0"
ctg_tile
shp_talhoes
View(shp_talhoes)
df_shp_talhoes <- shp_talhoes[-1593, ]
View(df_shp_talhoes)
D <- plot_metrics(ctg_tile, .stdmetrics_z, df_shp_talhoes)
var_boundaryweights <- (D$AREAPARCEL)/400
D$boundaryweights <- var_boundaryweights
X <- tibble(D) %>% select(Inventario, boundaryweights, MHDOM, IDINV, zmean,
zq45, zq75, zq95, VTCC, VCCC)
m <- lm(VTCC ~ zq95 + IDINV, data = X)    # Análise de Regressão Linear
summary(m)                          # Mostra os resultados da regressão
plot(X$VTCC, predict(m))              # Gráfico de observado vs predito
X
m <- lm(VTCC ~ zq95 + zmean, data = X)    # Análise de Regressão Linear
summary(m)                          # Mostra os resultados da regressão
plot(X$VTCC, predict(m))              # Gráfico de observado vs predito
m <- lm(VTCC ~ zq95, data = X)    # Análise de Regressão Linear
summary(m)                          # Mostra os resultados da regressão
plot(X$VTCC, predict(m))              # Gráfico de observado vs predito
m <- lm(VTCC ~ zq95, data = X)    # Análise de Regressão Linear
summary(m)                          # Mostra os resultados da regressão
plot(X$VTCC, predict(m))              # Gráfico de observado vs predito
m <- lm(VTCC ~ zmean, data = X)    # Análise de Regressão Linear
summary(m)                          # Mostra os resultados da regressão
plot(X$VTCC, predict(m))              # Gráfico de observado vs predito
m <- lm(VTCC ~ zmean, data = X)    # Análise de Regressão Linear
summary(m)                          # Mostra os resultados da regressão
plot(X$VTCC, predict(m))              # Gráfico de observado vs predito
plot(predict(m))              # Gráfico de observado vs predito
plot(X$VTCC)              # Gráfico de observado vs predito
teste_reg2p_nex <- twophase(formula = VTCC ~ zq75 + zmean,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
class(X$Inventario)
X$Inventario <- as.numeric(X$Inventario)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq75 + zmean,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
summary(teste_reg2p_nex)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + zmean,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
summary(teste_reg2p_nex)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
summary(teste_reg2p_nex)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + MHDOM,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
summary(teste_reg2p_nex)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = X, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
summary(teste_reg2p_nex)
datDir
lidDir
shpDir
dirTal
dirNrm
dirTNrm
ctg_gSiN
dirParc
save.image("C:/GitRepo/PRJ_FAZENDAMODELO/BATCHR/20-08.RData")
