####
excel
####
somaDasNotas <- c(excel$Copa + excel$Cunhamento + excel$Camisa + excel$Porta + excel$Tatu + excel$Piso)
####
somaDasNotas <- c(as.numeric(excel$Copa + excel$Cunhamento + excel$Camisa + excel$Porta + excel$Tatu + excel$Piso))
####
somaaux <- as.numeric(excel$Copa, excel$Cunhamento, excel$Camisa, excel$Porta, excel$Tatu, excel$Piso)
somaaux
(excel$Copa
excel$Copa
excel
excel$Cunhamento
s <- ggplot(mpg, aes(fl, fill = drv))
s + geom_bar(position = "stack")
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black") +
geom_bar(position = "stack")
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(position = "stack") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
#gera gráfico de barras simples
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
s <- ggplot(mpg, aes(fl, fill = drv))
s + geom_bar(position = "stack")
#Lê arquivo e cria df
excel <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/notas-yes-no.csv')
excel <- as.data.frame(excel)
descarteLinha <- nrow(excel) - 1
# Fornos
vetorNumForno <- c(7, 15, 16, 18, 20, 43, 59, 64, 65, 69, 73, 75, 77, 79, 83, 87, 89)
#vetor auxiliar para gerar gráfico
vetoraux <- 1:descarteLinha
#A última linha guarda informações de média para cada parte do forno e não será utilizada
mediaFornos <- excel$Media_fornos[-descarteLinha] #guarda médias
cor <- excel$Corregistro[-nrow(excel)] #guarda situação do corregistro
#Cria df com a média, identificação e situação do corregistro de cada forno
dfMedia <- data.frame(Numeracao_forno = vetorNumForno, Media = mediaFornos, Corregistro = cor)
#gera gráfico de barras simples
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
excel
s <- ggplot(excel, aes(Soma_fornos, fill = Cunhamento))
s + geom_bar(position = "stack")
excel
## Gráfico de barras empilhadas
dadosSemGeral <- excel[-nrow(excel)]
dadosSemGeral
## Gráfico de barras empilhadas
dadosSemGeral <- excel[-vetoraux]
dadosSemGeral
vetoraux
## Gráfico de barras empilhadas
dadosSemGeral <- excel[-descarteLinha]
dadosSemGeral
descarteLinha
## Gráfico de barras empilhadas
dadosSemGeral <- excel[-descarteLinha,]
dadosSemGeral
## Gráfico de barras empilhadas
dadosSemGeral <- excel[-nrow(excel),]
dadosSemGeral
s <- ggplot(excel, aes(Soma_fornos, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Soma_fornos, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(x = vetoraux, y = Soma_fornos, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Soma_fornos, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Forno, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Forno, fill = Cunhamento, Piso))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Forno, fill = Cunhamento))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Forno, fill = Corregistro))
s + geom_bar(position = "stack")
s <- ggplot(dadosSemGeral, aes(Forno, fill = Soma_notas))
s + geom_bar(position = "stack")
dadosSemGeral
s <- ggplot(dadosSemGeral, aes(Forno, fill = Soma_fornos))
s + geom_bar(position = "stack")
s <- ggplot(mpg, aes(cty, fill = drv))
s + geom_bar(position = "fill")
mpg
bd <- read.csv("teste.csv")
bd <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/teste.csv')
bd <- as.data.frame(bd)
bd
bd <- bd[-7,]
bd
bdsoma <- as.data.frame(bd)
bdsoma <- bdsoma[8,]
bdsoma
bdsoma <- as.data.frame(bd)
bdsoma <- bdsoma[7,]
bdsoma
bd <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/teste.csv')
bdsoma <- as.data.frame(bd)
bdsoma <- bdsoma[7,]
bd <- bd[-7,]
bdsoma
bd
bdsoma
bd <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/teste.csv')
s <- ggplot(bd, aes(Notas, fill = Parte))
s + geom_bar(position = "fill")
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
require(ggthemes)
require("ggthemes")
install.packages(ggthemes)
require(scales)
pl <- ggplot(data = mpg, aes(x = manufacter))
pl
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = mpg, aes(x = manufacturer))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = mpg, aes(x = manufacturer, fill = class))
pl <- pl + geom_bar(stat = "count")
pl
mpg
pl <- ggplot(data = mpg, aes(x = manufacturer))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = mpg, aes(x = manufacturer, fill = class))
pl <- pl + geom_bar(stat = "count")
pl
dfMedia
## Gráfico de barras empilhadas
excelSemMDGeral
excel
## Gráfico de barras empilhadas
excelSemMDGeral <- excel[-18,]
excelSemMDGeral
bd
pl <- ggplot(data = bd, aes(x = Notas, fill = Parte))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = bd, aes(y = Notas, fill = Parte))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = bd, aes(x = Notas, fill = Parte))
pl <- pl + geom_bar(stat = "count")
pl
#Lê arquivo e cria df
excel <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/notas-yes-no.csv')
excel <- as.data.frame(excel)
#**######################### Gráfico ######################
#Retirada de linha
descarteLinha <- nrow(excel) - 1
# Fornos
vetorNumForno <- c(7, 15, 16, 18, 20, 43, 59, 64, 65, 69, 73, 75, 77, 79, 83, 87, 89)
#vetor auxiliar para gerar gráfico
vetoraux <- 1:descarteLinha
mediaFornos <- excel$Media_fornos[-descarteLinha] #guarda médias
cor <- excel$Corregistro[-nrow(excel)] #guarda situação do corregistro
#Cria df com a média, identificação e situação do corregistro de cada forno
dfMedia <- data.frame(Numeracao_forno = vetorNumForno, Media = mediaFornos, Corregistro = cor)
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
#Lê arquivo e cria df
excel <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/notas-yes-no.csv')
#Lê arquivo e cria df
excel <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/notas-yes-no.csv')
excel <- as.data.frame(excel)
descarteLinha <- nrow(excel) - 1
# Fornos
vetorNumForno <- c(7, 15, 16, 18, 20, 43, 59, 64, 65, 69, 73, 75, 77, 79, 83, 87, 89)
#vetor auxiliar para gerar gráfico
vetoraux <- 1:descarteLinha
#A última linha guarda informações de média para cada parte do forno e não será utilizada
mediaFornos <- excel$Media_fornos[-descarteLinha] #guarda médias
cor <- excel$Corregistro[-nrow(excel)] #guarda situação do corregistro
#Cria df com a média, identificação e situação do corregistro de cada forno
dfMedia <- data.frame(Numeracao_forno = vetorNumForno, Media = mediaFornos, Corregistro = cor)
#gera gráfico de barras simples
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
p <- ggplot(mpg, aes(displ, hwy)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(class))
## Gráfico de barras empilhadas
excelSemMDGeral
mpg
excelSemMDGeral
## Gráfico de barras empilhadas
excelteste <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/testegrfp.csv')
excelteste
View(excelteste)
View(excelteste)
## Gráfico de barras empilhadas
excelteste <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/testegrfp.csv')
excelteste
p <- ggplot(excelteste, aes(id, notas)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
excelteste
p <- ggplot(excelteste, aes(id, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Forno))
p <- ggplot(excelteste, aes(, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
excelteste
p <- ggplot(excelteste, aes(Forno, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(Forno, Nota)) + geom_bar(stat = "identity")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") #+ gemo_text(aes())
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
excelteste
## Gráfico de barras empilhadas
excelteste <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/testegrfp.csv')
excelteste
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") #+ gemo_text(aes())
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") + gemo_text(aes(x = id, label = Forno))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno))
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno)) + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno)) + xlab("")
## Gráfico de barras empilhadas
excelempilhadas <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/grfbarrasempilhadas.csv')
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno)) + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_point() + geom_text(aes(x = id, label = Forno)) + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno), colour = "white") + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno), colour = "red") + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno), colour = "green") + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
library(ggplot2)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(sf)
library(leaflet)
library(kableExtra)
library(lidR)
library(DescTools)
library(gtsummary)
knitr::opts_chunk$set(echo = TRUE)
prjNam <- "PRJ_GERDAU"
wrkDir <- str_c('C:/GitRepo/', prjNam)
datDir <- str_c('C:/3D/TLS/', prjNam)
\newpage
\newpage
library(ggplot2)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(sf)
library(leaflet)
library(kableExtra)
library(lidR)
library(DescTools)
library(gtsummary)
knitr::opts_chunk$set(echo = TRUE)
prjNam <- "PRJ_GERDAU"
wrkDir <- str_c('C:/GitRepo/', prjNam)
datDir <- str_c('C:/3D/TLS/', prjNam)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(sf)
library(leaflet)
library(kableExtra)
library(lidR)
library(DescTools)
library(gtsummary)
knitr::opts_chunk$set(echo = TRUE)
prjNam <- "PRJ_GERDAU"
wrkDir <- str_c('C:/GitRepo/', prjNam)
datDir <- str_c('C:/3D/TLS/', prjNam)
dirNoN
dirProjet <- str_c('C:/GitRepo/',prjNam) # Define diretório de trabalho
if(!require(tidyverse))    # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
if(!require(sf))            # Para manipulação de shapes e outros tipos
install.packages("sf")                      # de dados espacializados
library(sf)
if(!require(tidyterra))           # Package para processar mapas raster
install.packages("tidyterra")
library(tidyterra)
if(!require(terra))           # Package para processar mapas raster
install.packages("terra")
library(terra)
if(!require(stars))                  # Package que permite rasterização
install.packages("stars")
library(stars)
if(!require(tools))           # Package para manipular nomes de aquivos
install.packages("tools")
library(tools)
if(!require(RColorBrewer))          # Package com mais paletas de cores
install.packages("RColorBrewer")
library(RColorBrewer)
if(!require(progress))          # Package com mais paletas de cores
install.packages("progress")
library(progress)
if(!require(reshape2))              # Usado na função que gera gráficos
install.packages("reshape2")         # mais caprichados de correlação
library(reshape2)
if(!require(mapview))             # Package para incluir mapas de fundo
install.packages("mapview")
library(mapview)
# devtools::install_github("Jean-Romain/rlas", dependencies=TRUE)
# devtools::install_github("Jean-Romain/lidR")
if(!require(lidR))                     # PARA MANPULAÇÃO DE DADOS LiDAR
install.packages("lidR") # Se preferir instalar a versão mais recente
library(lidR)              # e tiver o package devtools instalado, rode
# alternativamente as duas linhas acima
if(!require(RCSF))    #        Pacote complementar do lidR e necessário
install.packages("RCSF")           # rodar a função classify_ground()
library(RCSF)
if(!require(future))         # Package que permite ao lidR rodar usando
install.packages("future")          # processamento paralelo de dados
library(future)
dirProjet <- str_c('C:/GitRepo/',prjNam) # Define diretório de trabalho
if (!dir.exists(dirProjet)) {          # Cria diretório caso não exista
dir.create('C:/GitRepo/', showWarnings = F)
dir.create(dirProjet, showWarnings = F)
}
setwd(dirProjet)                     # Define pasta default de trabalho
datDir <- str_c('C:/LiDAR/', prjNam)    # Define raiz da pasta de dados
if (!dir.exists(datDir)) {           # Cria diretórios caso não existam
dir.create('C:/LiDAR/', showWarnings = F)
dir.create(datDir, showWarnings = F)
}
lidDir <- str_c(datDir, '/NUVENS/')     # Cria sub-pasta p/ dados LiDAR
if (!dir.exists(lidDir)) {
dir.create(lidDir, showWarnings = F)
}
anoData <- c("A13")                  # Lê apenas os dados LiDAR de 2013
dirLAZ  <- str_c(lidDir, anoData[1])   #  Define local das nuvens LiDAR
ctg_orig <- readLAScatalog(dirLAZ) # LEITURA DAS NUVENS DE PONTOS LiDAR
gitOnde <-
"https://github.com/FlorestaR/dados/blob/main/5_LIDARF/Modelo/SHAPES"
gitNome <- "fazmodelo.zip"                   # shapes da fazenda modelo
gitArqv <- file.path(gitOnde, gitNome) %>% str_c("?raw=true")
tmpd <- tempdir(check = TRUE)                    # diretório temporário
zipf <- file.path(tmpd, "shapes.zip")              # arquivo temporário
# Download e unzip do coonteúdo do arquivo zipado
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
options(timeout=1000)
if(!file.exists(zipf)) {
download.file(gitArqv, mode="wb", destfile = zipf)
}
shpDir <- str_c(dirProjet, '/SHAPES') # Define diretório para os shapes
if (!dir.exists(shpDir)) {             # Cria diretório caso não exista
dir.create(shpDir, showWarnings = F)
}
unzip(zipf, exdir = shpDir)   # unzipa shps e guarda na pasta de shapes
unlink(zipf)                                  # deleta o arquivo zipado
# ----
dirLAZ  <- str_c(lidDir, anoData[1])   #  Define local das nuvens LiDAR
ctg_orig <- readLAScatalog(dirLAZ) # LEITURA DAS NUVENS DE PONTOS LiDAR
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
rm(list=ls(all=TRUE))                                   # Limpa memória
gc()
if(!require(tidyverse))    # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
if(!require(sf))            # Para manipulação de shapes e outros tipos
install.packages("sf")                      # de dados espacializados
library(sf)
if(!require(tidyterra))           # Package para processar mapas raster
install.packages("tidyterra")
library(tidyterra)
if(!require(terra))           # Package para processar mapas raster
install.packages("terra")
library(terra)
if(!require(stars))                  # Package que permite rasterização
install.packages("stars")
library(stars)
if(!require(tools))           # Package para manipular nomes de aquivos
install.packages("tools")
library(tools)
if(!require(RColorBrewer))          # Package com mais paletas de cores
install.packages("RColorBrewer")
library(RColorBrewer)
if(!require(progress))          # Package com mais paletas de cores
install.packages("progress")
library(progress)
if(!require(reshape2))              # Usado na função que gera gráficos
install.packages("reshape2")         # mais caprichados de correlação
library(reshape2)
if(!require(mapview))             # Package para incluir mapas de fundo
install.packages("mapview")
library(mapview)
# devtools::install_github("Jean-Romain/rlas", dependencies=TRUE)
# devtools::install_github("Jean-Romain/lidR")
if(!require(lidR))                     # PARA MANPULAÇÃO DE DADOS LiDAR
install.packages("lidR") # Se preferir instalar a versão mais recente
library(lidR)              # e tiver o package devtools instalado, rode
# alternativamente as duas linhas acima
if(!require(RCSF))    #        Pacote complementar do lidR e necessário
install.packages("RCSF")           # rodar a função classify_ground()
library(RCSF)
if(!require(future))         # Package que permite ao lidR rodar usando
install.packages("future")          # processamento paralelo de dados
library(future)
prjNam <- "PRJ_FAZENDAMODELO"                               # Nomeia o projeto
dirProjet <- str_c('C:/GitRepo/',prjNam) # Define diretório de trabalho
if (!dir.exists(dirProjet)) {          # Cria diretório caso não exista
dir.create('C:/GitRepo/', showWarnings = F)
dir.create(dirProjet, showWarnings = F)
}
setwd(dirProjet)                     # Define pasta default de trabalho
datDir <- str_c('C:/LiDAR/', prjNam)    # Define raiz da pasta de dados
if (!dir.exists(datDir)) {           # Cria diretórios caso não existam
dir.create('C:/LiDAR/', showWarnings = F)
dir.create(datDir, showWarnings = F)
}
lidDir <- str_c(datDir, '/NUVENS/')     # Cria sub-pasta p/ dados LiDAR
if (!dir.exists(lidDir)) {
dir.create(lidDir, showWarnings = F)
}
anoData <- c("A13")                  # Lê apenas os dados LiDAR de 2013
dirLAZ  <- str_c(lidDir, anoData[1])   #  Define local das nuvens LiDAR
ctg_orig <- readLAScatalog(dirLAZ) # LEITURA DAS NUVENS DE PONTOS LiDAR
opt_select(ctg_orig) <- "xyzic"
shpArq  <- str_c(shpDir, "/Modelo_talhoes.shp")      # shape de talhões
gitOnde <-
"https://github.com/FlorestaR/dados/blob/main/5_LIDARF/Modelo/SHAPES"
gitNome <- "fazmodelo.zip"                   # shapes da fazenda modelo
gitArqv <- file.path(gitOnde, gitNome) %>% str_c("?raw=true")
tmpd <- tempdir(check = TRUE)                    # diretório temporário
zipf <- file.path(tmpd, "shapes.zip")              # arquivo temporário
# Download e unzip do coonteúdo do arquivo zipado
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
options(timeout=1000)
if(!file.exists(zipf)) {
download.file(gitArqv, mode="wb", destfile = zipf)
}
shpDir <- str_c(dirProjet, '/SHAPES') # Define diretório para os shapes
if (!dir.exists(shpDir)) {             # Cria diretório caso não exista
dir.create(shpDir, showWarnings = F)
}
unzip(zipf, exdir = shpDir)   # unzipa shps e guarda na pasta de shapes
unlink(zipf)
shpArq  <- str_c(shpDir, "/Modelo_talhoes.shp")      # shape de talhões
tal_shp <- st_read(shpArq)
st_is_valid(tal_shp)        # confere se os elementos do shape estão OK
dirTal <- str_c(dirLAZ, '/TALHOES')        # Pasta p/ nuvens por talhao
if (!dir.exists(dirTal)) {
dir.create(dirTal, showWarnings = F)
}
dirTal
ctg_orig
str_c(dirTal, "/{SUBTALHAO}")
dirLAZ
gitNome
gitArqv
ctg_orig
D
