bdsoma
bd <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/teste.csv')
bdsoma <- as.data.frame(bd)
bdsoma <- bdsoma[7,]
bd <- bd[-7,]
bdsoma
bd
bdsoma
bd <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/teste.csv')
s <- ggplot(bd, aes(Notas, fill = Parte))
s + geom_bar(position = "fill")
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
require(ggthemes)
require("ggthemes")
install.packages(ggthemes)
require(scales)
pl <- ggplot(data = mpg, aes(x = manufacter))
pl
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = mpg, aes(x = manufacturer))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = mpg, aes(x = manufacturer, fill = class))
pl <- pl + geom_bar(stat = "count")
pl
mpg
pl <- ggplot(data = mpg, aes(x = manufacturer))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = mpg, aes(x = manufacturer, fill = class))
pl <- pl + geom_bar(stat = "count")
pl
dfMedia
## Gráfico de barras empilhadas
excelSemMDGeral
excel
## Gráfico de barras empilhadas
excelSemMDGeral <- excel[-18,]
excelSemMDGeral
bd
pl <- ggplot(data = bd, aes(x = Notas, fill = Parte))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = bd, aes(y = Notas, fill = Parte))
pl <- pl + geom_bar(stat = "count")
pl
pl <- ggplot(data = bd, aes(x = Notas, fill = Parte))
pl <- pl + geom_bar(stat = "count")
pl
#Lê arquivo e cria df
excel <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/notas-yes-no.csv')
excel <- as.data.frame(excel)
#**######################### Gráfico ######################
#Retirada de linha
descarteLinha <- nrow(excel) - 1
# Fornos
vetorNumForno <- c(7, 15, 16, 18, 20, 43, 59, 64, 65, 69, 73, 75, 77, 79, 83, 87, 89)
#vetor auxiliar para gerar gráfico
vetoraux <- 1:descarteLinha
mediaFornos <- excel$Media_fornos[-descarteLinha] #guarda médias
cor <- excel$Corregistro[-nrow(excel)] #guarda situação do corregistro
#Cria df com a média, identificação e situação do corregistro de cada forno
dfMedia <- data.frame(Numeracao_forno = vetorNumForno, Media = mediaFornos, Corregistro = cor)
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
#Lê arquivo e cria df
excel <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/notas-yes-no.csv')
#Lê arquivo e cria df
excel <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/notas-yes-no.csv')
excel <- as.data.frame(excel)
descarteLinha <- nrow(excel) - 1
# Fornos
vetorNumForno <- c(7, 15, 16, 18, 20, 43, 59, 64, 65, 69, 73, 75, 77, 79, 83, 87, 89)
#vetor auxiliar para gerar gráfico
vetoraux <- 1:descarteLinha
#A última linha guarda informações de média para cada parte do forno e não será utilizada
mediaFornos <- excel$Media_fornos[-descarteLinha] #guarda médias
cor <- excel$Corregistro[-nrow(excel)] #guarda situação do corregistro
#Cria df com a média, identificação e situação do corregistro de cada forno
dfMedia <- data.frame(Numeracao_forno = vetorNumForno, Media = mediaFornos, Corregistro = cor)
#gera gráfico de barras simples
ggplot(dfMedia, aes(x = vetoraux, y = Media, fill = Corregistro)) + #delimita quais serão os eixos e segrega por cor de acordo com a situação do corregistro
xlab("") + # tira texto do eixo X
ylab("Média do forno") + # altera texto do eixo Y
geom_bar(stat = "identity") + #usa os dados de entrada sem nenhuma transformação
ggtitle("Médias dos fornos corregistrados") + # adiciona título
geom_text(aes(x = vetoraux, label = vetorNumForno), colour = "black")
p <- ggplot(mpg, aes(displ, hwy)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(class))
## Gráfico de barras empilhadas
excelSemMDGeral
mpg
excelSemMDGeral
## Gráfico de barras empilhadas
excelteste <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/testegrfp.csv')
excelteste
View(excelteste)
View(excelteste)
## Gráfico de barras empilhadas
excelteste <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/testegrfp.csv')
excelteste
p <- ggplot(excelteste, aes(id, notas)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
excelteste
p <- ggplot(excelteste, aes(id, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Forno))
p <- ggplot(excelteste, aes(, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
excelteste
p <- ggplot(excelteste, aes(Forno, Nota)) + geom_point()
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(Forno, Nota)) + geom_bar(stat = "identity")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") #+ gemo_text(aes())
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
excelteste
## Gráfico de barras empilhadas
excelteste <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/testegrfp.csv')
excelteste
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") #+ gemo_text(aes())
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") + gemo_text(aes(x = id, label = Forno))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno))
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelteste, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno)) + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno)) + xlab("")
## Gráfico de barras empilhadas
excelempilhadas <- read.csv('C:/ForlidarD/PRJGRAFICOSFORNOS/grfbarrasempilhadas.csv')
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno)) + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_point() + geom_text(aes(x = id, label = Forno)) + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno), colour = "white") + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno), colour = "red") + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
p <- ggplot(excelempilhadas, aes(id, Nota)) + geom_bar(stat = "identity") + geom_text(aes(x = id, label = Forno), colour = "green") + xlab("")
# Use vars() to supply faceting variables:
p + facet_wrap(vars(Classe))
library(ggplot2)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(sf)
library(leaflet)
library(kableExtra)
library(lidR)
library(DescTools)
library(gtsummary)
knitr::opts_chunk$set(echo = TRUE)
prjNam <- "PRJ_GERDAU"
wrkDir <- str_c('C:/GitRepo/', prjNam)
datDir <- str_c('C:/3D/TLS/', prjNam)
\newpage
\newpage
library(ggplot2)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(sf)
library(leaflet)
library(kableExtra)
library(lidR)
library(DescTools)
library(gtsummary)
knitr::opts_chunk$set(echo = TRUE)
prjNam <- "PRJ_GERDAU"
wrkDir <- str_c('C:/GitRepo/', prjNam)
datDir <- str_c('C:/3D/TLS/', prjNam)
library(ggplot2)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(sf)
library(leaflet)
library(kableExtra)
library(lidR)
library(DescTools)
library(gtsummary)
knitr::opts_chunk$set(echo = TRUE)
prjNam <- "PRJ_GERDAU"
wrkDir <- str_c('C:/GitRepo/', prjNam)
datDir <- str_c('C:/3D/TLS/', prjNam)
prjNam    <- "PRJ_FAZENDAMODELO"                             # Nome do projeto
dirRaizNuvens <- str_c('C:/LiDAR/',prjNam, '/NUVENS') # Raiz das nuvens
if(!require(tidyverse))    # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
if(!require(sf))            # Para manipulação de shapes e outros tipos
install.packages("sf")                      # de dados espacializados
library(sf)
if(!require(tidyterra))           # Package para processar mapas raster
install.packages("tidyterra")
library(tidyterra)
if(!require(terra))           # Package para processar mapas raster
install.packages("terra")
library(terra)
if(!require(stars))                  # Package que permite rasterização
install.packages("stars")
library(stars)
if(!require(tools))           # Package para manipular nomes de aquivos
install.packages("tools")
library(tools)
if(!require(RColorBrewer))          # Package com mais paletas de cores
install.packages("RColorBrewer")
library(RColorBrewer)
if(!require(progress))          # Package com mais paletas de cores
install.packages("progress")
library(progress)
if(!require(reshape2))              # Usado na função que gera gráficos
install.packages("reshape2")         # mais caprichados de correlação
library(reshape2)
if(!require(mapview))             # Package para incluir mapas de fundo
install.packages("mapview")
library(mapview)
# devtools::install_github("Jean-Romain/rlas", dependencies=TRUE)
# devtools::install_github("Jean-Romain/lidR")
if(!require(lidR))                     # PARA MANPULAÇÃO DE DADOS LiDAR
install.packages("lidR") # Se preferir instalar a versão mais recente
library(lidR)              # e tiver o package devtools instalado, rode
# alternativamente as duas linhas acima
if(!require(RCSF))    #        Pacote complementar do lidR e necessário
install.packages("RCSF")           # rodar a função classify_ground()
library(RCSF)
if(!require(future))         # Package que permite ao lidR rodar usando
install.packages("future")          # processamento paralelo de dados
library(future)
varteste = 0
if(!require(tidyverse))    # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
if(!require(sf))            # Para manipulação de shapes e outros tipos
install.packages("sf")                      # de dados espacializados
library(sf)
if(!require(tidyterra))           # Package para processar mapas raster
install.packages("tidyterra")
library(tidyterra)
if(!require(terra))           # Package para processar mapas raster
install.packages("terra")
library(terra)
if(!require(stars))                  # Package que permite rasterização
install.packages("stars")
library(stars)
if(!require(tools))           # Package para manipular nomes de aquivos
install.packages("tools")
library(tools)
if(!require(RColorBrewer))          # Package com mais paletas de cores
install.packages("RColorBrewer")
library(RColorBrewer)
if(!require(progress))          # Package com mais paletas de cores
install.packages("progress")
library(progress)
if(!require(reshape2))              # Usado na função que gera gráficos
install.packages("reshape2")         # mais caprichados de correlação
library(reshape2)
if(!require(mapview))             # Package para incluir mapas de fundo
install.packages("mapview")
library(mapview)
if(!require(forestinventory))             # Package para incluir mapas de fundo
install.packages("forestinventory")
library(forestinventory)
# devtools::install_github("Jean-Romain/rlas", dependencies=TRUE)
# devtools::install_github("Jean-Romain/lidR")
if(!require(lidR))                     # PARA MANPULAÇÃO DE DADOS LiDAR
install.packages("lidR") # Se preferir instalar a versão mais recente
library(lidR)              # e tiver o package devtools instalado, rode
# alternativamente as duas linhas acima
if(!require(RCSF))    #        Pacote complementar do lidR e necessário
install.packages("RCSF")           # rodar a função classify_ground()
library(RCSF)
if(!require(future))         # Package que permite ao lidR rodar usando
install.packages("future")          # processamento paralelo de dados
library(future)
prjNam <- "PRJ_FAZENDAMODELO"                               # Nomeia o projeto
varteste = 0
dirProjet <- str_c('C:/GitRepo/',prjNam) # Define diretório de trabalho
if (!dir.exists(dirProjet)) {          # Cria diretório caso não exista
dir.create('C:/GitRepo/', showWarnings = F)
dir.create(dirProjet, showWarnings = F)
}
setwd(dirProjet)                     # Define pasta default de trabalho
datDir <- str_c('C:/LiDAR/', prjNam)    # Define raiz da pasta de dados
if (!dir.exists(datDir)) {           # Cria diretórios caso não existam
dir.create('C:/LiDAR/', showWarnings = F)
dir.create(datDir, showWarnings = F)
}
lidDir <- str_c(datDir, '/NUVENS/')     # Cria sub-pasta p/ dados LiDAR
if (!dir.exists(lidDir)) {
dir.create(lidDir, showWarnings = F)
}
dirLAZ  <- str_c(lidDir, anoData[1])   #  Define local das nuvens LiDAR
anoData <- c("A13")                  # Lê apenas os dados LiDAR de 2013
dirLAZ  <- str_c(lidDir, anoData[1])   #  Define local das nuvens LiDAR
ctg_orig <- readLAScatalog(dirLAZ) # LEITURA DAS NUVENS DE PONTOS LiDAR
opt_select(ctg_orig) <- "xyzic" # Só atributos xyz intensid. e classif.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Lê shape e atributos dos talhoes
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shpArq  <- str_c(shpDir, "/Modelo_talhoes.shp")      # shape de talhões
dirTal <- str_c(dirLAZ, '/TALHOES')        # Pasta p/ nuvens por talhao
if (!dir.exists(dirTal)) {
dir.create(dirTal, showWarnings = F)
}
dirNoN <- str_c(dirTal, '/NoNORM') # Nuvens c/ ground não normalizadas
if (!dir.exists(dirNoN)) {
dir.create(dirNoN, showWarnings = F)
}
dirNrm <- str_c(dirTal, '/SiNORM')       # Pasta p/ nuvens normalizadas
if (!dir.exists(dirNrm)) {
dir.create(dirNrm, showWarnings = F)
}
dirTNrm <- str_c(dirNrm, '/TILES')        # Pasta p/ tiles normalizados
if (!dir.exists(dirTNrm)) {
dir.create(dirTNrm, showWarnings = F)
}
# crashou
ctg_gSiN <- readLAScatalog(dirNrm)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
shpPar  <- str_c("C:/GitRepo/PRJ_FAZENDAMODELO/SHAPES/Modelo_parcentr.shp")    # shape de parcelas
par_shp <- st_read(shpPar)
st_is_valid(par_shp)        # confere se os elementos do shape estão OK
dirParc <- str_c(dirNrm, '/PARCELAS')      # Pasta p/ parcelas clipadas
if (!dir.exists(dirParc)) {
dir.create(dirParc, showWarnings = F)
}
opt_output_files(ctg_gSiN) <-     # Onde guardar as nuvens normalizadas
str_c(dirTNrm, "/FzMod_{XLEFT}_{YBOTTOM}")    # renomeadas com coords
opt_chunk_buffer(ctg_gSiN) <- 0     # sem buffers ao redor de cada tile
opt_chunk_size(ctg_gSiN) <- 300                     # em tiles de 300 m
opt_laz_compression(ctg_gSiN) <- TRUE              # Mantém formato LAZ
ctg_tile <- catalog_retile(ctg_gSiN)                        # e executa
D1 <- plot_metrics(ctg_tile, .stdmetrics_z, shp_talhoes)
shp_arquivo  <- "C:/GitRepo/PRJ_FAZENDAMODELO/SHAPES/Grid_finalizado.shp"
shp_talhoes <- st_read(shp_arquivo)
D1 <- plot_metrics(ctg_tile, .stdmetrics_z, shp_talhoes)
opt_output_files(ctg_gSiN) <-     # Onde guardar as nuvens normalizadas
str_c(dirTNrm, "/FzMod_{XLEFT}_{YBOTTOM}")    # renomeadas com coords
opt_chunk_buffer(ctg_gSiN) <- 0     # sem buffers ao redor de cada tile
opt_chunk_size(ctg_gSiN) <- 300                     # em tiles de 300 m
opt_laz_compression(ctg_gSiN) <- TRUE              # Mantém formato LAZ
ctg_tile <- catalog_retile(ctg_gSiN)                        # e executa
rm(ctg_gNoN, ctg_gSiN, ctg_orig, ctg_talh)
ctg_tile
shp_talhoes
View(shp_talhoes)
.stdmetrics_z
D1 <- plot_metrics(ctg_tile, .stdmetrics_z, shp_talhoes)
D1
nrow(shp_talhoes)
nrow(ctg_tile)
opt_output_files(ctg_gSiN) <-     # Onde guardar as nuvens normalizadas
str_c(dirTNrm, "/FzMod_{XLEFT}_{YBOTTOM}")    # renomeadas com coords
# crashou
ctg_gSiN <- readLAScatalog(dirNrm)
opt_output_files(ctg_gSiN) <-     # Onde guardar as nuvens normalizadas
str_c(dirTNrm, "/FzMod_{XLEFT}_{YBOTTOM}")    # renomeadas com coords
opt_chunk_buffer(ctg_gSiN) <- 0     # sem buffers ao redor de cada tile
opt_chunk_size(ctg_gSiN) <- 100                     # em tiles de 300 m
opt_laz_compression(ctg_gSiN) <- TRUE              # Mantém formato LAZ
ctg_tile <- catalog_retile(ctg_gSiN)                        # e executa
rm(ctg_gNoN, ctg_gSiN, ctg_orig, ctg_talh)
View(shp_talhoes)
plot(shp_talhoes$id == 5603)
df_shp_talhoes <- shp_talhoes[-1593, ]
View(df_shp_talhoes)
D1 <- plot_metrics(ctg_tile, .stdmetrics_z, df_shp_talhoes)
D1
View(D1)
var_boundaryweights <- (D1$AREAPARCEL)/400
var_boundaryweights
D1$boundaryweights <- var_boundaryweights
View(D1)
D1$boundaryweights
head(D1)
Xteste <- tibble(D1) %>% select(Inventario, boundaryweights, MHDOM, IDINV, zmean,
zq45, zq75, zq95, VTCC, VCCC)
head(Xteste)
m1 <- lm(VTCC ~ zq95 + IDINV, data = Xteste)    # Análise de Regressão Linear
summary(m1)                          # Mostra os resultados da regressão
plot(Xteste$VTCC, predict(m1))              # Gráfico de observado vs predito
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = Xteste, phase_id = list
(phase.col = "Inventario", terrgrid.id = 2))
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = Xteste, phase_id = list (phase.col = "Inventario", terrgrid.id = 2))
class(Xteste$Inventario)
Xteste$Inventario <- as.integer(Xteste$Inventario)
class(Xteste$Inventario)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = Xteste, phase_id = list (phase.col = "Inventario", terrgrid.id = 2))
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = Xteste, phase_id = list (phase.col = "Inventario", terrgrid.id = 2))
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = Xteste, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
if(!require(tidyverse))    # Para melhor manipulação de dados e funções
install.packages("tidyverse")
library(tidyverse)
if(!require(sf))            # Para manipulação de shapes e outros tipos
install.packages("sf")                      # de dados espacializados
library(sf)
if(!require(tidyterra))           # Package para processar mapas raster
install.packages("tidyterra")
library(tidyterra)
if(!require(terra))           # Package para processar mapas raster
install.packages("terra")
library(terra)
if(!require(stars))                  # Package que permite rasterização
install.packages("stars")
library(stars)
if(!require(tools))           # Package para manipular nomes de aquivos
install.packages("tools")
library(tools)
if(!require(RColorBrewer))          # Package com mais paletas de cores
install.packages("RColorBrewer")
library(RColorBrewer)
if(!require(progress))          # Package com mais paletas de cores
install.packages("progress")
library(progress)
if(!require(reshape2))              # Usado na função que gera gráficos
install.packages("reshape2")         # mais caprichados de correlação
library(reshape2)
if(!require(mapview))             # Package para incluir mapas de fundo
install.packages("mapview")
library(mapview)
if(!require(forestinventory))             # Package para incluir mapas de fundo
install.packages("forestinventory")
library(forestinventory)
# devtools::install_github("Jean-Romain/rlas", dependencies=TRUE)
# devtools::install_github("Jean-Romain/lidR")
if(!require(lidR))                     # PARA MANPULAÇÃO DE DADOS LiDAR
install.packages("lidR") # Se preferir instalar a versão mais recente
library(lidR)              # e tiver o package devtools instalado, rode
# alternativamente as duas linhas acima
if(!require(RCSF))    #        Pacote complementar do lidR e necessário
install.packages("RCSF")           # rodar a função classify_ground()
library(RCSF)
if(!require(future))         # Package que permite ao lidR rodar usando
install.packages("future")          # processamento paralelo de dados
library(future)
#cores  <- as.integer(parallel::detectCores() - 4)
#plan(multisession, workers = cores)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define pastas e local de trabalho
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prjNam <- "PRJ_FAZENDAMODELO"                               # Nomeia o projeto
varteste = 0
dirProjet <- str_c('C:/GitRepo/',prjNam) # Define diretório de trabalho
if (!dir.exists(dirProjet)) {          # Cria diretório caso não exista
dir.create('C:/GitRepo/', showWarnings = F)
dir.create(dirProjet, showWarnings = F)
}
setwd(dirProjet)                     # Define pasta default de trabalho
datDir <- str_c('C:/LiDAR/', prjNam)    # Define raiz da pasta de dados
if (!dir.exists(datDir)) {           # Cria diretórios caso não existam
dir.create('C:/LiDAR/', showWarnings = F)
dir.create(datDir, showWarnings = F)
}
lidDir <- str_c(datDir, '/NUVENS/')     # Cria sub-pasta p/ dados LiDAR
if (!dir.exists(lidDir)) {
dir.create(lidDir, showWarnings = F)
}
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV,
data = Xteste, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
Xteste
teste_reg2p_nex <- twophase(formula = VTCC ~ zq95,
data = Xteste, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
summary(teste_reg2p_nex)
teste_reg2p_nex <- twophase(formula = VTCC ~ IDINV,
data = Xteste, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
class(Xteste$IDINV)
Xteste$IDINV <- as.double(Xteste$IDINV)
teste_reg2p_nex <- twophase(formula = VTCC ~ IDINV,
data = Xteste, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
Xteste$IDINV <- as.numeric(Xteste$IDINV)
teste_reg2p_nex <- twophase(formula = VTCC ~ zq75 + zmean,
data = Xteste, phase_id = list (phase.col = "Inventario",
terrgrid.id = 2), boundary_weights = "boundaryweights")
summary(teste_reg2p_nex)
View(Xteste)
