sum(talhoes_final$AREAPARCEL < 1)
sum(talhoes_final$AREAPARCEL > 1)
metrics_list <- list() # Inicializa uma lista para armazenar as métricas de cada parcela
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Adicionar um identificador de parcela em aux_df_shp_talhoes
df_shp_talhoes$parcela_id <- 1:nrow(talhoes_final)  # Assumindo que cada linha é uma parcela diferente
nrow(shp_parcela)
shp_parcela
View(shp_parcela)
metrics_list <- list() # Inicializa uma lista para armazenar as métricas de cada parcela
# Loop sobre cada parcela no shapefile
for (i in 1:20) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, talhoes_final)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
for (i in 1:20) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, talhoes_final)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
teste_talhoes_final <- talhoes_final[,1:20]
teste_talhoes_final
teste_talhoes_final <- talhoes_final[,1:20]
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(teste_talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- teste_talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, teste_talhoes_final)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
las_crop <- clip_roi(ctg_tile, teste_talhoes_final)
ctg_tile
View(ctg_tile)
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile[1:20], teste_talhoes_final)  # Retorna um LAScatalog
View(teste_talhoes_final)
teste_talhoes_final <- talhoes_final[1:20,]
teste_talhoes_final <- talhoes_final[1:20,]
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(teste_talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- teste_talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, teste_talhoes_final)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Adicionar um identificador de parcela em aux_df_shp_talhoes
df_shp_talhoes$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
View(df_shp_talhoes)
df_shp_final <- df_shp_talhoes %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 1))
# Adicionar um identificador de parcela em aux_df_shp_talhoes
df_shp_final$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Adicionar um identificador de parcela em aux_df_shp_talhoes
df_shp_final$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
teste <- df_shp_final[1:20,]
# Adicionar um identificador de parcela em aux_df_shp_talhoes
teste$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
View(metrics_df_final)
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
metrics_list <- list() # Inicializa uma lista para armazenar as métricas de cada parcela
teste_talhoes_final <- talhoes_final[1:20,]
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(teste_talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- teste_talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, teste_talhoes_final)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
metrics_df_final
View(metrics_df_final)
View(teste_talhoes_final)
View(teste_talhoes_final)
for (i in 1:nrow(teste_talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- teste_talhoes_final[i, ]  # Pegue a i-ésima parcela
}
shp_parcela
View(shp_parcela)
nrow(teste_talhoes_final)
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
df_shp_final <- df_shp_talhoes %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 1))
df_shp_final <- teste_talhoes_final %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 1))
# Adicionar um identificador de parcela em aux_df_shp_talhoes
teste$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
nrow(teste_talhoes_final)
ncol(metrics_df_final)
View(metrics_df_final)
# Adicionar um identificador de parcela em aux_df_shp_talhoes
teste_talhoes_final$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
View(final_df)
for (i in 1:nrow(teste_talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- teste_talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$parcela_id <- i  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
df_shp_final <- teste_talhoes_final %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 1))
# Adicionar um identificador de parcela em aux_df_shp_talhoes
teste_talhoes_final$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
View(final_df)
teste_talhoes_final <- teste_talhoes_final %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 180))
# Adicionar um identificador de parcela em aux_df_shp_talhoes
teste_talhoes_final$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
teste_talhoes_final <- talhoes_final[1:20,]
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
teste_talhoes_final <- teste_talhoes_final %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 180))
View(metrics_df_final)
# Adicionar um identificador de parcela em aux_df_shp_talhoes
teste_talhoes_final$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
teste_talhoes_final <- talhoes_final[1:20,]
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Adicionar um identificador de parcela em aux_df_shp_talhoes
teste_talhoes_final$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
teste_talhoes_final <- teste_talhoes_final %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 180))
# Adicionar um identificador de parcela em aux_df_shp_talhoes
teste_talhoes_final$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
teste_talhoes_final <- talhoes_final[1:20,]
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Adicionar um identificador de parcela em aux_df_shp_talhoes
teste_talhoes_final$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
teste_talhoes_final <- teste_talhoes_final %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 180))
# Adicionar um identificador de parcela em aux_df_shp_talhoes
teste_talhoes_final$parcela_id <- 1:nrow(teste_talhoes_final)  # Assumindo que cada linha é uma parcela diferente
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
metrics_list <- list() # Inicializa uma lista para armazenar as métricas de cada parcela
teste_talhoes_final <- talhoes_final[1:20,]
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(teste_talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- teste_talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$id <- teste_talhoes_final$id[i]  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
teste_talhoes_final <- teste_talhoes_final %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 180))
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
nrow(teste_talhoes_final)
nrow(metrics_df_final)
teste_talhoes_final <- teste_talhoes_final %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 180))
for (i in 1:nrow(teste_talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- teste_talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$id <- teste_talhoes_final$id[i]  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
nrow(teste_talhoes_final)
nrow(metrics_df_final)
teste_talhoes_final <- talhoes_final[1:20,]
nrow(teste_talhoes_final)
teste_talhoes_final <- teste_talhoes_final %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 180))
nrow(teste_talhoes_final)
for (i in 1:nrow(teste_talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- teste_talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
teste_talhoes_final <- talhoes_final[1:20,]
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(teste_talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- teste_talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
metrics_df_final
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "parcela_id")
nrow(teste_talhoes_final)
nrow(metrics_df_final)
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "id")
teste_talhoes_final <- talhoes_final[1:20,]
for (i in 1:nrow(teste_talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- teste_talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$id <- teste_talhoes_final$id[i]  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "id")
final_df <- merge(teste_talhoes_final, metrics_df_final, by = "id") %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 180))
# Seleciona apenas as parcelas em que a área é maior do que 1 m²
talhoes_final <- shp_talhoes %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 1))
metrics_list <- list() # Inicializa uma lista para armazenar as métricas de cada parcela
# Loop sobre cada parcela no shapefile
for (i in 1:nrow(talhoes_final)) { # Para cada número de linhas do data frame que contém as informações
shp_parcela <- talhoes_final[i, ]  # Pegue a i-ésima parcela
# Recorte os pontos LiDAR para essa parcela e converta para LAS
las_crop <- clip_roi(ctg_tile, shp_parcela)  # Retorna um LAScatalog
# Verifique se o retorno é um LAScatalog, e se sim, converta para LAS
if (class(las_crop) == "LAScatalog") {
# Processa o LAScatalog para obter os pontos LiDAR dentro da parcela
las_crop <- readLAS(las_crop)
}
# Verifique se a parcela contém pontos LiDAR
if (!is.null(las_crop)) {
# Calcule as métricas para essa parcela
metrics <- cloud_metrics(las_crop, func = .stdmetrics_z)
# Converta as métricas para um data frame e adicione um identificador da parcela
metrics_df <- as.data.frame(t(metrics))  # Transforma as métricas em um data frame com uma linha
metrics_df$id <- talhoes_final$id[i]  # Adicione o identificador da parcela (opcional)
# Armazene as métricas no data frame
metrics_list[[i]] <- metrics_df
} else {
# Se não houver pontos na parcela, armazene NA
metrics_list[[i]] <- data.frame(parcela_id = i, zmean = NA, zmax = NA, zmin = NA)  # Exemplo de colunas
}
}
# Combine todas as métricas em um único data frame
metrics_df_final <- do.call(rbind, metrics_list)
# Fazer o merge das métricas com os dados do aux_df_shp_talhoes
final_df <- merge(talhoes_final, metrics_df_final, by = "id") %>%
filter_at(vars(AREAPARCEL), all_vars(. >= 1))
X <- tibble(final_df) %>% select(Inventario, boundaryweights, MHDOM, IDINV, zmean,
zq45, zq75, zq95, VTCC, VCCC)
var_boundaryweights <- (final_df$AREAPARCEL)/400
final_df$boundaryweights <- var_boundaryweights
X <- tibble(final_df) %>% select(Inventario, boundaryweights, MHDOM, IDINV, zmean,
zq45, zq75, zq95, VTCC, VCCC)
X$Inventario <- as.integer(X$Inventario) # Converter coluna Inventario para Integer (número) - Deve estar em algum formato numérico para ser reconecida pela função twophase()
X <- as.data.frame(X) # Tibble não é uma função nativa do R, é uma função chamada pelo tidyverse. Dessa forma, o formato da tabela que é gerada não é reconhecido pela função twophase() do package forestinventory. O forestinventory reconhece data frames
reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV, # formula relaciona os valores de VTCC com zq95 e IDINV
data = X, #  Base de dados utilizada
phase_id = list(phase.col = "Inventario", terrgrid.id = 2)) # phase_id recebe uma lista em que a coluna a ser analisada é a Inventario e o identificador da segunda fase é 2
class(X)
# EU POR ALGUM MOTIVO NAO CONSIDEREI AS PARCELAS DE CAMPO COM 3.7 ANOS. O CAMINHO ESTÁ CERTO, MAS HOUVE ESSE ERRO
class(X$Inventario)
X$Inventario <- as.numeric(X$Inventario) # Converter coluna Inventario para Integer (número) - Deve estar em algum formato numérico para ser reconecida pela função twophase()
reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV, # formula relaciona os valores de VTCC com zq95 e IDINV
data = X, #  Base de dados utilizada
phase_id = list(phase.col = "Inventario", terrgrid.id = 2))
# EU POR ALGUM MOTIVO NAO CONSIDEREI AS PARCELAS DE CAMPO COM 3.7 ANOS. O CAMINHO ESTÁ CERTO, MAS HOUVE ESSE ERRO
class(X$zq95)
X$zq95 <- as.numeric(X$zq95)
X$IDINV <- as.numeric(X$IDINV)
reg2p_nex <- twophase(formula = VTCC ~ zq95 + IDINV, # formula relaciona os valores de VTCC com zq95 e IDINV
data = X, #  Base de dados utilizada
phase_id = list(phase.col = "Inventario", terrgrid.id = 2)) #
summary(reg2p_nex) # Dá os resultados da Dupla Amostragem
m <- lm(VTCC ~ zq95 + IDINV, data = X)    # Análise de Regressão Linear
summary(m)                          # Mostra os resultados da regressão
VTCCparcelas <- X$VTCC[!is.na(X$VTCC)] # VTCCparcelas recebe os valores não nulos de VTCC contidos em X, ou seja, recebe os valores de VTCC das parcelas de campo
plot(VTCCparcelas, predict(m))              # Gráfico de observado vs predito
abline(0,1)
save.image("C:/GitRepo/PRJ_FAZENDAMODELO/BATCHR/DA-forestinventory-finalizada.RData")
